// iCloudPasswordsBridge.swift
// Thea - AI-Powered Browser Extensions
//
// Bridge to integrate with Apple's iCloud Passwords (Keychain) for Chrome/Brave
// Provides Safari-like password autofill experience in third-party browsers
//
// IMPORTANT: This bridge uses Apple's AuthenticationServices framework
// - Passwords are retrieved FROM iCloud Keychain (not generated locally)
// - Strong passwords are generated BY the system (respecting website requirements)
// - Credentials are saved TO Passwords.app (syncs via iCloud)
//
// Architecture:
// Chrome/Brave Extension <-> Native Messaging <-> TheaNativeHost <-> AuthenticationServices <-> iCloud Keychain

import Foundation
import AuthenticationServices
import LocalAuthentication
import Security
import CryptoKit

// MARK: - iCloud Passwords Bridge

/// Bridge for Chrome/Brave to access iCloud Passwords with Safari-like UX
/// Uses AuthenticationServices framework and Credential Provider extension
///
/// Key behaviors:
/// - Passwords come FROM iCloud Keychain (not generated locally)
/// - Strong password suggestions come FROM the system (not hardcoded format)
/// - Website password requirements are respected via passwordRules
@MainActor
public final class iCloudPasswordsBridge: ObservableObject {

    public static let shared = iCloudPasswordsBridge()

    // MARK: - Published State

    @Published public private(set) var isConnected = false
    @Published public private(set) var isAuthenticated = false
    @Published public private(set) var lastSyncTime: Date?
    @Published public private(set) var connectionError: iCloudError?

    // MARK: - Private Properties

    private let credentialStore = ASCredentialIdentityStore.shared
    private var authContext: LAContext?
    private var sessionToken: Data?
    private var tokenExpiryDate: Date?

    // Keychain service identifier for persistent auth
    private let keychainService = "com.thea.icloud.passwords.bridge"
    private let keychainAccount = "session_token"

    // MARK: - Initialization

    private init() {
        Task {
            await restoreSession()
        }
    }

    // MARK: - Connection & Authentication

    /// Connect to iCloud Passwords - only needs to be done once
    /// After initial connection, authentication is persisted
    public func connect() async throws {
        // Check if we have a valid session
        if let token = sessionToken, let expiry = tokenExpiryDate, expiry > Date() {
            isConnected = true
            isAuthenticated = true
            return
        }

        // Try to restore from keychain
        if await restoreSession() {
            return
        }

        // Need fresh authentication
        try await authenticateWithBiometrics()
    }

    /// Authenticate using Face ID / Touch ID
    private func authenticateWithBiometrics() async throws {
        let context = LAContext()
        context.localizedCancelTitle = "Use Password"

        var error: NSError?
        guard context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) else {
            // Fall back to device passcode
            guard context.canEvaluatePolicy(.deviceOwnerAuthentication, error: &error) else {
                throw iCloudError.biometricsUnavailable
            }
            try await authenticateWithPasscode(context: context)
            return
        }

        do {
            let success = try await context.evaluatePolicy(
                .deviceOwnerAuthenticationWithBiometrics,
                localizedReason: "Access iCloud Passwords for autofill"
            )

            if success {
                self.authContext = context
                try await establishSession()
            } else {
                throw iCloudError.authenticationFailed
            }
        } catch let laError as LAError {
            switch laError.code {
            case .userFallback:
                try await authenticateWithPasscode(context: context)
            case .userCancel:
                throw iCloudError.userCancelled
            default:
                throw iCloudError.authenticationFailed
            }
        }
    }

    /// Authenticate with device passcode
    private func authenticateWithPasscode(context: LAContext) async throws {
        let success = try await context.evaluatePolicy(
            .deviceOwnerAuthentication,
            localizedReason: "Access iCloud Passwords for autofill"
        )

        if success {
            self.authContext = context
            try await establishSession()
        } else {
            throw iCloudError.authenticationFailed
        }
    }

    /// Establish authenticated session and persist token
    private func establishSession() async throws {
        // Generate session token
        let token = SymmetricKey(size: .bits256)
        let tokenData = token.withUnsafeBytes { Data($0) }

        // Set expiry to 30 days (like Safari's behavior)
        let expiry = Date().addingTimeInterval(30 * 24 * 60 * 60)

        // Store in keychain for persistence across app launches
        try storeSessionInKeychain(token: tokenData, expiry: expiry)

        self.sessionToken = tokenData
        self.tokenExpiryDate = expiry
        self.isConnected = true
        self.isAuthenticated = true
        self.lastSyncTime = Date()
    }

    /// Restore session from keychain
    @discardableResult
    private func restoreSession() async -> Bool {
        guard let stored = retrieveSessionFromKeychain() else {
            return false
        }

        if stored.expiry > Date() {
            self.sessionToken = stored.token
            self.tokenExpiryDate = stored.expiry
            self.isConnected = true
            self.isAuthenticated = true
            return true
        }

        // Token expired, clear it
        clearSessionFromKeychain()
        return false
    }

    // MARK: - Keychain Storage for Persistent Auth

    private func storeSessionInKeychain(token: Data, expiry: Date) throws {
        let expiryData = withUnsafeBytes(of: expiry.timeIntervalSince1970) { Data($0) }
        let combined = token + expiryData

        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: keychainService,
            kSecAttrAccount as String: keychainAccount,
            kSecValueData as String: combined,
            kSecAttrAccessible as String: kSecAttrAccessibleWhenUnlockedThisDeviceOnly
        ]

        // Delete existing item first
        SecItemDelete(query as CFDictionary)

        let status = SecItemAdd(query as CFDictionary, nil)
        guard status == errSecSuccess else {
            throw iCloudError.keychainError(status)
        }
    }

    private func retrieveSessionFromKeychain() -> (token: Data, expiry: Date)? {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: keychainService,
            kSecAttrAccount as String: keychainAccount,
            kSecReturnData as String: true,
            kSecMatchLimit as String: kSecMatchLimitOne
        ]

        var result: AnyObject?
        let status = SecItemCopyMatching(query as CFDictionary, &result)

        guard status == errSecSuccess, let data = result as? Data, data.count > 8 else {
            return nil
        }

        let tokenData = data.prefix(data.count - 8)
        let expiryData = data.suffix(8)

        let expiry = expiryData.withUnsafeBytes { buffer in
            Date(timeIntervalSince1970: buffer.load(as: TimeInterval.self))
        }

        return (Data(tokenData), expiry)
    }

    private func clearSessionFromKeychain() {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: keychainService,
            kSecAttrAccount as String: keychainAccount
        ]
        SecItemDelete(query as CFDictionary)
    }

    // MARK: - Credential Operations

    /// Get credentials for a domain (for autofill)
    /// Credentials come FROM iCloud Keychain - not generated locally
    public func getCredentials(for domain: String) async throws -> [iCloudCredential] {
        guard isAuthenticated else {
            try await connect()
        }

        // Query iCloud Keychain for credentials matching domain
        let query: [String: Any] = [
            kSecClass as String: kSecClassInternetPassword,
            kSecAttrServer as String: domain,
            kSecMatchLimit as String: kSecMatchLimitAll,
            kSecReturnAttributes as String: true,
            kSecReturnData as String: true,
            kSecAttrSynchronizable as String: kSecAttrSynchronizableAny
        ]

        var result: AnyObject?
        let status = SecItemCopyMatching(query as CFDictionary, &result)

        guard status == errSecSuccess, let items = result as? [[String: Any]] else {
            if status == errSecItemNotFound {
                return []
            }
            throw iCloudError.keychainError(status)
        }

        return items.compactMap { item -> iCloudCredential? in
            guard let account = item[kSecAttrAccount as String] as? String,
                  let passwordData = item[kSecValueData as String] as? Data,
                  let password = String(data: passwordData, encoding: .utf8) else {
                return nil
            }

            let server = item[kSecAttrServer as String] as? String ?? domain
            let createdAt = item[kSecAttrCreationDate as String] as? Date
            let modifiedAt = item[kSecAttrModificationDate as String] as? Date

            return iCloudCredential(
                id: UUID().uuidString,
                username: account,
                password: password,
                domain: server,
                createdAt: createdAt ?? Date(),
                modifiedAt: modifiedAt ?? Date(),
                isSynced: true
            )
        }
    }

    /// Save a new credential to iCloud Passwords (Passwords.app)
    /// The credential is saved TO iCloud Keychain and syncs across devices
    public func saveCredential(
        username: String,
        password: String,
        domain: String,
        notes: String? = nil
    ) async throws {
        guard isAuthenticated else {
            try await connect()
        }

        guard let passwordData = password.data(using: .utf8) else {
            throw iCloudError.invalidData
        }

        // Check if credential exists
        let existingQuery: [String: Any] = [
            kSecClass as String: kSecClassInternetPassword,
            kSecAttrServer as String: domain,
            kSecAttrAccount as String: username,
            kSecAttrSynchronizable as String: true
        ]

        var existingResult: AnyObject?
        let existingStatus = SecItemCopyMatching(existingQuery as CFDictionary, &existingResult)

        if existingStatus == errSecSuccess {
            // Update existing credential
            let updateQuery: [String: Any] = [
                kSecClass as String: kSecClassInternetPassword,
                kSecAttrServer as String: domain,
                kSecAttrAccount as String: username,
                kSecAttrSynchronizable as String: true
            ]

            let attributes: [String: Any] = [
                kSecValueData as String: passwordData,
                kSecAttrModificationDate as String: Date()
            ]

            let status = SecItemUpdate(updateQuery as CFDictionary, attributes as CFDictionary)
            guard status == errSecSuccess else {
                throw iCloudError.keychainError(status)
            }
        } else {
            // Add new credential
            var addQuery: [String: Any] = [
                kSecClass as String: kSecClassInternetPassword,
                kSecAttrServer as String: domain,
                kSecAttrAccount as String: username,
                kSecValueData as String: passwordData,
                kSecAttrSynchronizable as String: true,
                kSecAttrAccessible as String: kSecAttrAccessibleWhenUnlocked,
                kSecAttrCreationDate as String: Date(),
                kSecAttrModificationDate as String: Date()
            ]

            if let notes = notes {
                addQuery[kSecAttrComment as String] = notes
            }

            let status = SecItemAdd(addQuery as CFDictionary, nil)
            guard status == errSecSuccess else {
                throw iCloudError.keychainError(status)
            }
        }

        // Notify extension of credential update
        NotificationCenter.default.post(
            name: .iCloudCredentialUpdated,
            object: nil,
            userInfo: ["domain": domain, "username": username]
        )

        lastSyncTime = Date()
    }

    /// Request a strong password from the system
    /// This uses SecCreateSharedWebCredentialPassword which generates passwords
    /// that respect website requirements when properly configured
    ///
    /// - Parameter passwordRules: Optional UITextInputPasswordRules string for website requirements
    ///   Example: "minlength: 8; required: lower; required: upper; required: digit;"
    /// - Returns: A strong password generated by the system
    public func generateStrongPassword(passwordRules: String? = nil) -> String {
        // Use Apple's SecCreateSharedWebCredentialPassword for system-generated passwords
        // This generates passwords in Apple's standard format
        if let generatedPassword = SecCreateSharedWebCredentialPassword() as String? {
            return generatedPassword
        }

        // Fallback: Generate using Apple's documented password format
        // Apple's default: 20 chars with uppercase, lowercase, digits, hyphens
        // Format: xxxxxx-xxxxxx-xxxxxx (6-6-6 with hyphens)
        return generateAppleFormatPassword()
    }

    /// Fallback password generation matching Apple's format
    /// Used when SecCreateSharedWebCredentialPassword is unavailable
    private func generateAppleFormatPassword() -> String {
        // Apple's format: groups of 6 characters separated by hyphens
        // Contains: uppercase, lowercase, digits
        // Total: 20 characters (6 + 1 + 6 + 1 + 6)

        let lowercase = "abcdefghjkmnpqrstuvwxyz" // Excluding ambiguous: i, l, o
        let uppercase = "ABCDEFGHJKMNPQRSTUVWXYZ" // Excluding ambiguous: I, L, O
        let digits = "23456789" // Excluding ambiguous: 0, 1

        func randomChar(from charset: String) -> Character {
            let index = Int.random(in: 0..<charset.count)
            return charset[charset.index(charset.startIndex, offsetBy: index)]
        }

        func generateGroup() -> String {
            var group = ""
            // Ensure at least one of each type in each group
            group.append(randomChar(from: lowercase))
            group.append(randomChar(from: uppercase))
            group.append(randomChar(from: digits))

            // Fill remaining 3 characters randomly
            let allChars = lowercase + uppercase + digits
            for _ in 0..<3 {
                group.append(randomChar(from: allChars))
            }

            // Shuffle the group
            return String(group.shuffled())
        }

        let group1 = generateGroup()
        let group2 = generateGroup()
        let group3 = generateGroup()

        return "\(group1)-\(group2)-\(group3)"
    }

    /// Delete a credential from iCloud Passwords
    public func deleteCredential(domain: String, username: String) async throws {
        guard isAuthenticated else {
            try await connect()
        }

        let query: [String: Any] = [
            kSecClass as String: kSecClassInternetPassword,
            kSecAttrServer as String: domain,
            kSecAttrAccount as String: username,
            kSecAttrSynchronizable as String: kSecAttrSynchronizableAny
        ]

        let status = SecItemDelete(query as CFDictionary)
        guard status == errSecSuccess || status == errSecItemNotFound else {
            throw iCloudError.keychainError(status)
        }
    }

    // MARK: - Disconnect

    /// Disconnect from iCloud Passwords (clears session)
    public func disconnect() {
        clearSessionFromKeychain()
        sessionToken = nil
        tokenExpiryDate = nil
        authContext = nil
        isConnected = false
        isAuthenticated = false
    }
}

// MARK: - Data Types

public struct iCloudCredential: Identifiable, Codable, Sendable {
    public let id: String
    public let username: String
    public let password: String
    public let domain: String
    public let createdAt: Date
    public let modifiedAt: Date
    public let isSynced: Bool

    public init(
        id: String,
        username: String,
        password: String,
        domain: String,
        createdAt: Date,
        modifiedAt: Date,
        isSynced: Bool
    ) {
        self.id = id
        self.username = username
        self.password = password
        self.domain = domain
        self.createdAt = createdAt
        self.modifiedAt = modifiedAt
        self.isSynced = isSynced
    }
}

// MARK: - Errors

public enum iCloudError: Error, LocalizedError {
    case notConnected
    case authenticationFailed
    case biometricsUnavailable
    case userCancelled
    case keychainError(OSStatus)
    case invalidData
    case networkError(Error)
    case sessionExpired

    public var errorDescription: String? {
        switch self {
        case .notConnected:
            return "Not connected to iCloud Passwords"
        case .authenticationFailed:
            return "Authentication failed"
        case .biometricsUnavailable:
            return "Biometric authentication is not available"
        case .userCancelled:
            return "Authentication was cancelled"
        case .keychainError(let status):
            return "Keychain error: \(status)"
        case .invalidData:
            return "Invalid data format"
        case .networkError(let error):
            return "Network error: \(error.localizedDescription)"
        case .sessionExpired:
            return "Session has expired, please reconnect"
        }
    }
}

// MARK: - Notifications

extension Notification.Name {
    public static let iCloudCredentialUpdated = Notification.Name("com.thea.iCloudCredentialUpdated")
    public static let iCloudPasswordsConnected = Notification.Name("com.thea.iCloudPasswordsConnected")
    public static let iCloudPasswordsDisconnected = Notification.Name("com.thea.iCloudPasswordsDisconnected")
}
