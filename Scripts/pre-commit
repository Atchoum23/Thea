#!/bin/bash

################################################################################
# Git Pre-Commit Hook
# Validates code quality and scans for credentials before allowing commits
# Install: cp Scripts/pre-commit .git/hooks/pre-commit && chmod +x .git/hooks/pre-commit
################################################################################

set -e

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

echo -e "${BLUE}Running pre-commit checks...${NC}"

# Get project root
PROJECT_ROOT="$(git rev-parse --show-toplevel)"
cd "$PROJECT_ROOT"

FAILED=0

################################################################################
# Phase 1: Credential / Secret Scanning
################################################################################

echo -e "${BLUE}Phase 1: Scanning staged files for credentials...${NC}"

# Get all staged file content (not just names — we scan the actual staged content)
STAGED_FILES=$(git diff --cached --name-only --diff-filter=d || true)

if [ -n "$STAGED_FILES" ]; then
    CRED_FINDINGS=""

    while IFS= read -r file; do
        # Skip binary files, images, and non-text
        case "$file" in
            *.png|*.jpg|*.jpeg|*.gif|*.ico|*.icns|*.pdf|*.zip|*.tar|*.gz|*.dmg|*.app|*.xcarchive)
                continue ;;
            *.pbxproj|*.xcuserstate|*.xcscheme)
                continue ;;
        esac

        # Get the staged version of the file
        STAGED_CONTENT=$(git show ":$file" 2>/dev/null || true)
        [ -z "$STAGED_CONTENT" ] && continue

        # --- API Key Patterns ---

        # OpenAI / Anthropic API keys (sk-...)
        if echo "$STAGED_CONTENT" | grep -qE 'sk-[a-zA-Z0-9]{20,}'; then
            # Exclude test files and obviously fake keys
            case "$file" in
                Tests/*|*Tests.swift|*Test.swift) ;; # skip test files
                *)
                    # Check it's not a pattern/regex definition or test constant
                    if ! echo "$STAGED_CONTENT" | grep -qE '(pattern|regex|example|fake|test|dummy|placeholder).*sk-'; then
                        CRED_FINDINGS="${CRED_FINDINGS}\n  ${RED}CRITICAL:${NC} $file — Possible API key (sk-*)"
                    fi
                    ;;
            esac
        fi

        # GitHub tokens (ghp_, gho_, ghs_, github_pat_)
        if echo "$STAGED_CONTENT" | grep -qE '(ghp_|gho_|ghs_|github_pat_)[a-zA-Z0-9]{20,}'; then
            case "$file" in
                Tests/*|*Tests.swift|*Test.swift) ;;
                *) CRED_FINDINGS="${CRED_FINDINGS}\n  ${RED}CRITICAL:${NC} $file — Possible GitHub token" ;;
            esac
        fi

        # AWS keys (AKIA...)
        if echo "$STAGED_CONTENT" | grep -qE 'AKIA[0-9A-Z]{16}'; then
            case "$file" in
                Tests/*|*Tests.swift|*Test.swift) ;;
                *) CRED_FINDINGS="${CRED_FINDINGS}\n  ${RED}CRITICAL:${NC} $file — Possible AWS access key (AKIA*)" ;;
            esac
        fi

        # Google/Firebase API keys (AIzaSy...)
        if echo "$STAGED_CONTENT" | grep -qE 'AIzaSy[a-zA-Z0-9_-]{33}'; then
            case "$file" in
                Tests/*|*Tests.swift|*Test.swift) ;;
                *)
                    # Skip if it's obviously fake
                    if ! echo "$STAGED_CONTENT" | grep -qE '(FAKE|fake|test|dummy|placeholder|example).*AIzaSy'; then
                        CRED_FINDINGS="${CRED_FINDINGS}\n  ${RED}CRITICAL:${NC} $file — Possible Firebase/Google API key (AIzaSy*)"
                    fi
                    ;;
            esac
        fi

        # Slack tokens (xoxb-, xoxp-, xoxa-, xoxs-)
        if echo "$STAGED_CONTENT" | grep -qE 'xox[bpas]-[a-zA-Z0-9-]{20,}'; then
            case "$file" in
                Tests/*|*Tests.swift|*Test.swift) ;;
                *) CRED_FINDINGS="${CRED_FINDINGS}\n  ${RED}CRITICAL:${NC} $file — Possible Slack token (xox*-)" ;;
            esac
        fi

        # PEM private keys
        if echo "$STAGED_CONTENT" | grep -qE '-----BEGIN[A-Z ]*PRIVATE KEY-----'; then
            CRED_FINDINGS="${CRED_FINDINGS}\n  ${RED}CRITICAL:${NC} $file — PEM private key detected"
        fi

        # JWT tokens (eyJ... two dots)
        if echo "$STAGED_CONTENT" | grep -qE 'eyJ[a-zA-Z0-9_-]{20,}\.eyJ[a-zA-Z0-9_-]{20,}\.[a-zA-Z0-9_-]+'; then
            case "$file" in
                Tests/*|*Tests.swift|*Test.swift) ;;
                *) CRED_FINDINGS="${CRED_FINDINGS}\n  ${YELLOW}WARNING:${NC} $file — Possible JWT token" ;;
            esac
        fi

        # Generic password/secret assignments
        if echo "$STAGED_CONTENT" | grep -qiE '(password|secret|passwd|api_key|apikey|access_token)\s*[:=]\s*"[^"]{8,}"'; then
            case "$file" in
                Tests/*|*Tests.swift|*Test.swift|*.md|*.yml|*.yaml) ;;
                *)
                    # Skip if it's a pattern definition
                    if ! echo "$STAGED_CONTENT" | grep -qiE '(pattern|regex|detect|scan|match|example)'; then
                        CRED_FINDINGS="${CRED_FINDINGS}\n  ${YELLOW}WARNING:${NC} $file — Possible hardcoded secret/password"
                    fi
                    ;;
            esac
        fi

        # NordVPN credentials
        if echo "$STAGED_CONTENT" | grep -qiE 'nordvpn.*token|nord_.*key'; then
            case "$file" in
                Tests/*|*Tests.swift|*Test.swift) ;;
                *) CRED_FINDINGS="${CRED_FINDINGS}\n  ${RED}CRITICAL:${NC} $file — Possible NordVPN credential" ;;
            esac
        fi

        # TMDB API keys
        if echo "$STAGED_CONTENT" | grep -qiE 'tmdb.*api.*key\s*[:=]\s*"[a-f0-9]{20,}"'; then
            case "$file" in
                Tests/*|*Tests.swift|*Test.swift) ;;
                *) CRED_FINDINGS="${CRED_FINDINGS}\n  ${RED}CRITICAL:${NC} $file — Possible TMDB API key" ;;
            esac
        fi

    done <<< "$STAGED_FILES"

    if [ -n "$CRED_FINDINGS" ]; then
        echo -e "${RED}CREDENTIAL SCAN FAILED — potential secrets found in staged files:${NC}"
        echo -e "$CRED_FINDINGS"
        echo ""
        echo -e "${YELLOW}Actions:${NC}"
        echo -e "  1. Move secrets to Keychain or .env file (which is gitignored)"
        echo -e "  2. If this is a false positive in test/pattern code, use: git commit --no-verify"
        echo -e "  3. If the value is intentionally fake/placeholder, add 'FAKE' or 'placeholder' near it"
        FAILED=1
    else
        echo -e "${GREEN}No credentials detected in staged files${NC}"
    fi
else
    echo -e "${GREEN}No staged files to scan${NC}"
fi

################################################################################
# Phase 2: SwiftLint (if available)
################################################################################

SWIFT_FILES=$(git diff --cached --name-only --diff-filter=d | grep "\.swift$" || true)

if [ -n "$SWIFT_FILES" ]; then
    if command -v swiftlint &> /dev/null; then
        echo -e "${BLUE}Phase 2: Running SwiftLint on $(echo "$SWIFT_FILES" | wc -l | tr -d ' ') Swift files...${NC}"
        if ! echo "$SWIFT_FILES" | xargs swiftlint lint --quiet --force-exclude 2>/dev/null; then
            echo -e "${RED}SwiftLint found issues in staged files${NC}"
            FAILED=1
        else
            echo -e "${GREEN}SwiftLint passed${NC}"
        fi
    else
        echo -e "${YELLOW}Phase 2: SwiftLint not found (install with: brew install swiftlint)${NC}"
    fi
else
    echo -e "${BLUE}Phase 2: No Swift files to lint${NC}"
fi

################################################################################
# Result
################################################################################

if [ $FAILED -ne 0 ]; then
    echo ""
    echo -e "${RED}Pre-commit checks FAILED${NC}"
    echo -e "${YELLOW}Fix the issues above or use 'git commit --no-verify' to bypass${NC}"
    exit 1
fi

echo -e "${GREEN}All pre-commit checks passed${NC}"
exit 0
