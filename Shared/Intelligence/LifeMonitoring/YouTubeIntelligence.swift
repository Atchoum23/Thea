// YouTubeIntelligence.swift
// THEA - Learn from YouTube Content
// Created by Claude - February 2026
//
// Monitors YouTube Music for music preferences
// Monitors YouTube for podcast/video learning
// Extracts insights and knowledge from watched content

import Foundation
import OSLog

// MARK: - Content Types

/// Type of YouTube content
public enum YouTubeContentType: String, Sendable, CaseIterable {
    case music             // YouTube Music tracks
    case podcast           // Long-form podcast content
    case educational       // Educational videos
    case news              // News content
    case entertainment     // Entertainment
    case tutorial          // How-to videos
    case documentary       // Documentaries
    case lecture           // Academic lectures
    case interview         // Interviews
    case other

    public var learningValue: LearningValue {
        switch self {
        case .podcast, .educational, .lecture, .documentary:
            return .high
        case .tutorial, .interview, .news:
            return .medium
        case .entertainment, .music, .other:
            return .low
        }
    }

    public enum LearningValue: String, Sendable {
        case high, medium, low
    }
}

// MARK: - Watched Content

/// A piece of YouTube content that was watched
public struct WatchedContent: Identifiable, Sendable {
    public let id: UUID
    public let youtubeId: String
    public let title: String
    public let channelName: String
    public let channelId: String
    public let contentType: YouTubeContentType
    public let duration: TimeInterval
    public let watchedDuration: TimeInterval
    public let startedAt: Date
    public let endedAt: Date?
    public let thumbnailURL: String?
    public let tags: [String]
    public let category: String?
    public let transcript: ContentTranscript?
    public let extractedTopics: [ExtractedTopic]
    public let userEngagement: UserEngagement

    public struct UserEngagement: Sendable {
        public let completionRate: Double // 0-1
        public let liked: Bool?
        public let saved: Bool
        public let shared: Bool
        public let commented: Bool
        public let rewatchCount: Int

        public init(
            completionRate: Double,
            liked: Bool? = nil,
            saved: Bool = false,
            shared: Bool = false,
            commented: Bool = false,
            rewatchCount: Int = 0
        ) {
            self.completionRate = completionRate
            self.liked = liked
            self.saved = saved
            self.shared = shared
            self.commented = commented
            self.rewatchCount = rewatchCount
        }
    }

    public var wasCompleted: Bool {
        watchedDuration / duration > 0.8
    }

    public init(
        id: UUID = UUID(),
        youtubeId: String,
        title: String,
        channelName: String,
        channelId: String,
        contentType: YouTubeContentType,
        duration: TimeInterval,
        watchedDuration: TimeInterval,
        startedAt: Date,
        endedAt: Date? = nil,
        thumbnailURL: String? = nil,
        tags: [String] = [],
        category: String? = nil,
        transcript: ContentTranscript? = nil,
        extractedTopics: [ExtractedTopic] = [],
        userEngagement: UserEngagement
    ) {
        self.id = id
        self.youtubeId = youtubeId
        self.title = title
        self.channelName = channelName
        self.channelId = channelId
        self.contentType = contentType
        self.duration = duration
        self.watchedDuration = watchedDuration
        self.startedAt = startedAt
        self.endedAt = endedAt
        self.thumbnailURL = thumbnailURL
        self.tags = tags
        self.category = category
        self.transcript = transcript
        self.extractedTopics = extractedTopics
        self.userEngagement = userEngagement
    }
}

// MARK: - Content Transcript

/// Transcript of video/podcast content
public struct ContentTranscript: Sendable {
    public let segments: [TranscriptSegment]
    public let language: String
    public let isAutoGenerated: Bool

    public struct TranscriptSegment: Sendable {
        public let text: String
        public let startTime: TimeInterval
        public let endTime: TimeInterval
        public let speaker: String?
    }

    public var fullText: String {
        segments.map { $0.text }.joined(separator: " ")
    }

    public init(segments: [TranscriptSegment], language: String = "en", isAutoGenerated: Bool = true) {
        self.segments = segments
        self.language = language
        self.isAutoGenerated = isAutoGenerated
    }
}

// MARK: - Extracted Topic

/// A topic extracted from content
public struct ExtractedTopic: Identifiable, Sendable {
    public let id: UUID
    public let name: String
    public let category: String?
    public let relevanceScore: Double // 0-1
    public let mentions: Int
    public let keyQuotes: [String]
    public let relatedTopics: [String]
    public let timestamp: TimeInterval? // When first mentioned

    public init(
        id: UUID = UUID(),
        name: String,
        category: String? = nil,
        relevanceScore: Double,
        mentions: Int = 1,
        keyQuotes: [String] = [],
        relatedTopics: [String] = [],
        timestamp: TimeInterval? = nil
    ) {
        self.id = id
        self.name = name
        self.category = category
        self.relevanceScore = relevanceScore
        self.mentions = mentions
        self.keyQuotes = keyQuotes
        self.relatedTopics = relatedTopics
        self.timestamp = timestamp
    }
}

// MARK: - Music Track

/// A music track from YouTube Music
public struct MusicTrack: Identifiable, Sendable {
    public let id: UUID
    public let youtubeId: String
    public let title: String
    public let artist: String
    public let album: String?
    public let duration: TimeInterval
    public let genre: String?
    public let playCount: Int
    public let lastPlayed: Date
    public let isLiked: Bool
    public let addedToLibrary: Bool
    public let mood: [String]? // Detected mood tags
    public let tempo: String? // slow, medium, fast
    public let energy: String? // low, medium, high

    public init(
        id: UUID = UUID(),
        youtubeId: String,
        title: String,
        artist: String,
        album: String? = nil,
        duration: TimeInterval,
        genre: String? = nil,
        playCount: Int = 1,
        lastPlayed: Date = Date(),
        isLiked: Bool = false,
        addedToLibrary: Bool = false,
        mood: [String]? = nil,
        tempo: String? = nil,
        energy: String? = nil
    ) {
        self.id = id
        self.youtubeId = youtubeId
        self.title = title
        self.artist = artist
        self.album = album
        self.duration = duration
        self.genre = genre
        self.playCount = playCount
        self.lastPlayed = lastPlayed
        self.isLiked = isLiked
        self.addedToLibrary = addedToLibrary
        self.mood = mood
        self.tempo = tempo
        self.energy = energy
    }
}

// MARK: - Learning Insight

/// An insight extracted from consumed content
public struct LearningInsight: Identifiable, Sendable {
    public let id: UUID
    public let title: String
    public let summary: String
    public let sourceContent: [WatchedContent.ID]
    public let topics: [String]
    public let keyTakeaways: [String]
    public let actionItems: [String]?
    public let relevanceToUser: Double // 0-1
    public let createdAt: Date

    public init(
        id: UUID = UUID(),
        title: String,
        summary: String,
        sourceContent: [WatchedContent.ID],
        topics: [String],
        keyTakeaways: [String],
        actionItems: [String]? = nil,
        relevanceToUser: Double = 0.5
    ) {
        self.id = id
        self.title = title
        self.summary = summary
        self.sourceContent = sourceContent
        self.topics = topics
        self.keyTakeaways = keyTakeaways
        self.actionItems = actionItems
        self.relevanceToUser = relevanceToUser
        self.createdAt = Date()
    }
}

// MARK: - User Preferences

/// User's content preferences learned from watching patterns
public struct ContentPreferences: Sendable {
    public var favoriteChannels: [String: Int] // channel -> watch count
    public var favoriteTopics: [String: Int] // topic -> mentions
    public var preferredDuration: DurationPreference
    public var preferredContentTypes: [YouTubeContentType: Int]
    public var listeningTimeByHour: [Int: TimeInterval] // hour -> total duration
    public var musicMoods: [String: Int] // mood -> frequency
    public var learningGoals: [String]

    public enum DurationPreference: String, Sendable {
        case short               // < 10 min
        case medium              // 10-30 min
        case long                // 30-60 min
        case veryLong = "very_long" // > 60 min
    }

    public init() {
        self.favoriteChannels = [:]
        self.favoriteTopics = [:]
        self.preferredDuration = .medium
        self.preferredContentTypes = [:]
        self.listeningTimeByHour = [:]
        self.musicMoods = [:]
        self.learningGoals = []
    }
}

// MARK: - YouTube Intelligence Engine

/// Main engine for learning from YouTube content
public actor YouTubeIntelligence {
    private let logger = Logger(subsystem: "ai.thea.app", category: "YouTubeIntelligence")
    // MARK: - Singleton

    public static let shared = YouTubeIntelligence()

    // MARK: - Properties

    private var watchedContent: [UUID: WatchedContent] = [:]
    private var musicTracks: [UUID: MusicTrack] = [:]
    private var learningInsights: [LearningInsight] = []
    private var preferences = ContentPreferences()
    private var isRunning = false

    // Callbacks
    private var onContentWatched: ((WatchedContent) -> Void)?
    private var onMusicPlayed: ((MusicTrack) -> Void)?
    private var onInsightGenerated: ((LearningInsight) -> Void)?
    private var onTopicDiscovered: ((ExtractedTopic) -> Void)?

    // MARK: - Configuration

    public struct Configuration: Sendable {
        public var trackYouTubeMusic: Bool = true
        public var trackYouTubeVideos: Bool = true
        public var fetchTranscripts: Bool = true
        public var extractTopics: Bool = true
        public var generateInsights: Bool = true
        public var syncWithBrowserHistory: Bool = true
        public var minWatchTimeToTrack: TimeInterval = 30 // 30 seconds

        public init() {}
    }

    private var configuration: Configuration

    // MARK: - Initialization

    private init() {
        self.configuration = Configuration()
    }

    // MARK: - Configuration

    public func configure(_ config: Configuration) {
        self.configuration = config
    }

    public func configure(
        onContentWatched: @escaping @Sendable (WatchedContent) -> Void,
        onMusicPlayed: @escaping @Sendable (MusicTrack) -> Void,
        onInsightGenerated: @escaping @Sendable (LearningInsight) -> Void,
        onTopicDiscovered: @escaping @Sendable (ExtractedTopic) -> Void
    ) {
        self.onContentWatched = onContentWatched
        self.onMusicPlayed = onMusicPlayed
        self.onInsightGenerated = onInsightGenerated
        self.onTopicDiscovered = onTopicDiscovered
    }

    // MARK: - Lifecycle

    public func start() async {
        guard !isRunning else { return }
        isRunning = true

        // Start monitoring browser activity for YouTube
        await startBrowserMonitoring()

        // Periodically analyze and generate insights
        Task { [weak self] in
            while await (self?.checkIsRunning() ?? false) {
                await self?.generatePeriodicInsights()
                do {
                    try await Task.sleep(nanoseconds: 3600_000_000_000) // Every hour
                } catch {
                    break
                }
            }
        }
    }

    private func checkIsRunning() -> Bool {
        isRunning
    }

    public func stop() {
        isRunning = false
    }

    // MARK: - Content Tracking

    /// Log watched video content
    public func logWatchedContent(_ content: WatchedContent) async {
        watchedContent[content.id] = content
        updatePreferences(from: content)
        onContentWatched?(content)

        // Extract topics if we have transcript
        if configuration.extractTopics, let transcript = content.transcript {
            let topics = await extractTopics(from: transcript)
            for topic in topics {
                onTopicDiscovered?(topic)
            }
        }

        // Generate insight for educational content
        if content.contentType.learningValue == .high && content.wasCompleted {
            await generateInsightForContent(content)
        }
    }

    /// Log played music track
    public func logMusicTrack(_ track: MusicTrack) {
        if let existing = musicTracks.values.first(where: { $0.youtubeId == track.youtubeId }) {
            // Update existing
            musicTracks[existing.id] = MusicTrack(
                id: existing.id,
                youtubeId: track.youtubeId,
                title: track.title,
                artist: track.artist,
                album: track.album,
                duration: track.duration,
                genre: track.genre,
                playCount: existing.playCount + 1,
                lastPlayed: Date(),
                isLiked: track.isLiked || existing.isLiked,
                addedToLibrary: track.addedToLibrary || existing.addedToLibrary,
                mood: track.mood ?? existing.mood,
                tempo: track.tempo ?? existing.tempo,
                energy: track.energy ?? existing.energy
            )
        } else {
            musicTracks[track.id] = track
        }

        updateMusicPreferences(from: track)
        onMusicPlayed?(track)
    }

    // MARK: - Query

    /// Get watched content by type
    public func getWatchedContent(type: YouTubeContentType, limit: Int = 50) -> [WatchedContent] {
        watchedContent.values
            .filter { $0.contentType == type }
            .sorted { $0.startedAt > $1.startedAt }
            .prefix(limit)
            .map { $0 }
    }

    /// Get favorite channels
    public func getFavoriteChannels(limit: Int = 10) -> [(name: String, watchCount: Int)] {
        preferences.favoriteChannels
            .sorted { $0.value > $1.value }
            .prefix(limit)
            .map { ($0.key, $0.value) }
    }

    /// Get learned topics
    public func getLearnedTopics(limit: Int = 20) -> [(topic: String, mentions: Int)] {
        preferences.favoriteTopics
            .sorted { $0.value > $1.value }
            .prefix(limit)
            .map { ($0.key, $0.value) }
    }

    /// Get music listening stats
    public func getMusicStats() -> MusicStats {
        let tracks = Array(musicTracks.values)
        let totalPlayCount = tracks.reduce(0) { $0 + $1.playCount }
        let totalDuration = tracks.reduce(0.0) { $0 + $1.duration * Double($1.playCount) }

        // Most played
        let mostPlayed = tracks.sorted { $0.playCount > $1.playCount }.prefix(10).map { $0 }

        // Genre distribution
        var genres: [String: Int] = [:]
        for track in tracks {
            if let genre = track.genre {
                genres[genre, default: 0] += track.playCount
            }
        }

        // Artist distribution
        var artists: [String: Int] = [:]
        for track in tracks {
            artists[track.artist, default: 0] += track.playCount
        }

        return MusicStats(
            totalTracks: tracks.count,
            totalPlayCount: totalPlayCount,
            totalListeningTime: totalDuration,
            mostPlayedTracks: mostPlayed,
            topGenres: genres.sorted { $0.value > $1.value }.prefix(5).map { $0.key },
            topArtists: artists.sorted { $0.value > $1.value }.prefix(5).map { $0.key },
            likedCount: tracks.filter { $0.isLiked }.count,
            moodDistribution: preferences.musicMoods
        )
    }

    /// Get learning insights
    public func getLearningInsights(limit: Int = 20) -> [LearningInsight] {
        learningInsights
            .sorted { $0.createdAt > $1.createdAt }
            .prefix(limit)
            .map { $0 }
    }

    /// Get content preferences
    public func getPreferences() -> ContentPreferences {
        preferences
    }

    /// Search content by topic
    public func searchContent(topic: String) -> [WatchedContent] {
        let lowercasedTopic = topic.lowercased()
        return watchedContent.values.filter { content in
            content.title.lowercased().contains(lowercasedTopic) ||
            content.tags.contains { $0.lowercased().contains(lowercasedTopic) } ||
            content.extractedTopics.contains { $0.name.lowercased().contains(lowercasedTopic) }
        }
    }

    /// Get viewing time by day/hour
    public func getViewingPatterns() -> ViewingPatterns {
        var byHour: [Int: TimeInterval] = [:]
        var byDayOfWeek: [Int: TimeInterval] = [:]
        var byContentType: [YouTubeContentType: TimeInterval] = [:]

        for content in watchedContent.values {
            let hour = Calendar.current.component(.hour, from: content.startedAt)
            let dayOfWeek = Calendar.current.component(.weekday, from: content.startedAt)

            byHour[hour, default: 0] += content.watchedDuration
            byDayOfWeek[dayOfWeek, default: 0] += content.watchedDuration
            byContentType[content.contentType, default: 0] += content.watchedDuration
        }

        return ViewingPatterns(
            byHour: byHour,
            byDayOfWeek: byDayOfWeek,
            byContentType: byContentType,
            peakHour: byHour.max { $0.value < $1.value }?.key ?? 12,
            peakDay: byDayOfWeek.max { $0.value < $1.value }?.key ?? 1
        )
    }

    // MARK: - Private Methods

    private func startBrowserMonitoring() async {
        // Would integrate with BrowserMonitor to detect YouTube activity
        // Monitor for:
        // - youtube.com/watch URLs
        // - music.youtube.com URLs
        // - YouTube Music app activity
    }

    private func updatePreferences(from content: WatchedContent) {
        // Update channel preferences
        preferences.favoriteChannels[content.channelName, default: 0] += 1

        // Update content type preferences
        preferences.preferredContentTypes[content.contentType, default: 0] += 1

        // Update viewing time by hour
        let hour = Calendar.current.component(.hour, from: content.startedAt)
        preferences.listeningTimeByHour[hour, default: 0] += content.watchedDuration

        // Update topic preferences
        for topic in content.extractedTopics {
            preferences.favoriteTopics[topic.name, default: 0] += topic.mentions
        }

        // Update duration preference
        let durationMinutes = content.duration / 60
        if durationMinutes < 10 {
            preferences.preferredDuration = .short
        } else if durationMinutes < 30 {
            preferences.preferredDuration = .medium
        } else if durationMinutes < 60 {
            preferences.preferredDuration = .long
        } else {
            preferences.preferredDuration = .veryLong
        }
    }

    private func updateMusicPreferences(from track: MusicTrack) {
        // Update mood preferences
        if let moods = track.mood {
            for mood in moods {
                preferences.musicMoods[mood, default: 0] += 1
            }
        }

        // Update listening time by hour
        let hour = Calendar.current.component(.hour, from: track.lastPlayed)
        preferences.listeningTimeByHour[hour, default: 0] += track.duration
    }

    private func extractTopics(from transcript: ContentTranscript) async -> [ExtractedTopic] {
        var topics: [String: (count: Int, quotes: [String], firstTimestamp: TimeInterval?)] = [:]

        // Simple keyword extraction (real implementation would use NLP)
        let stopWords = Set(["the", "a", "an", "is", "are", "was", "were", "be", "been", "being",
                            "have", "has", "had", "do", "does", "did", "will", "would", "could",
                            "should", "may", "might", "must", "shall", "can", "need", "dare",
                            "ought", "used", "to", "of", "in", "for", "on", "with", "at", "by",
                            "from", "as", "into", "through", "during", "before", "after",
                            "above", "below", "between", "under", "again", "further", "then",
                            "once", "here", "there", "when", "where", "why", "how", "all",
                            "each", "few", "more", "most", "other", "some", "such", "no",
                            "nor", "not", "only", "own", "same", "so", "than", "too", "very",
                            "just", "and", "but", "if", "or", "because", "until", "while"])

        for segment in transcript.segments {
            let words = segment.text.lowercased()
                .components(separatedBy: CharacterSet.alphanumerics.inverted)
                .filter { $0.count > 3 && !stopWords.contains($0) }

            for word in words {
                if topics[word] == nil {
                    topics[word] = (count: 1, quotes: [], firstTimestamp: segment.startTime)
                } else {
                    topics[word]!.count += 1
                }
            }
        }

        // Take top topics
        return topics
            .filter { $0.value.count >= 3 } // Must appear at least 3 times
            .sorted { $0.value.count > $1.value.count }
            .prefix(10)
            .map { topic in
                ExtractedTopic(
                    name: topic.key.capitalized,
                    relevanceScore: min(Double(topic.value.count) / 10.0, 1.0),
                    mentions: topic.value.count,
                    timestamp: topic.value.firstTimestamp
                )
            }
    }

    private func generateInsightForContent(_ content: WatchedContent) async {
        guard let transcript = content.transcript else { return }

        // Generate summary (simplified - real implementation would use LLM)
        let fullText = transcript.fullText
        let sentences = fullText.components(separatedBy: ". ")
        let summary = sentences.prefix(3).joined(separator: ". ")

        let insight = LearningInsight(
            title: "Learned from: \(content.title)",
            summary: summary.isEmpty ? "Content from \(content.channelName)" : summary,
            sourceContent: [content.id],
            topics: content.extractedTopics.map { $0.name },
            keyTakeaways: content.extractedTopics.prefix(5).map { $0.name },
            relevanceToUser: calculateRelevance(content)
        )

        learningInsights.append(insight)
        onInsightGenerated?(insight)
    }

    private func generatePeriodicInsights() async {
        // Look for patterns across recent content
        let recentContent = watchedContent.values
            .filter { Calendar.current.isDate($0.startedAt, equalTo: Date(), toGranularity: .weekOfYear) }

        guard recentContent.count >= 3 else { return }

        // Find common topics this week
        var topicCounts: [String: Int] = [:]
        for content in recentContent {
            for topic in content.extractedTopics {
                topicCounts[topic.name, default: 0] += 1
            }
        }

        let commonTopics = topicCounts
            .filter { $0.value >= 2 }
            .sorted { $0.value > $1.value }
            .prefix(5)
            .map { $0.key }

        if !commonTopics.isEmpty {
            let insight = LearningInsight(
                title: "This Week's Learning Focus",
                summary: "You've been exploring \(commonTopics.joined(separator: ", ")) across multiple videos this week.",
                sourceContent: recentContent.map { $0.id },
                topics: commonTopics,
                keyTakeaways: ["Consider deep-diving into \(commonTopics.first ?? "these topics")"],
                relevanceToUser: 0.8
            )

            learningInsights.append(insight)
            onInsightGenerated?(insight)
        }
    }

    private func calculateRelevance(_ content: WatchedContent) -> Double {
        var relevance = 0.5

        // Boost if from favorite channel
        if preferences.favoriteChannels[content.channelName, default: 0] > 5 {
            relevance += 0.2
        }

        // Boost if covers favorite topics
        let favoriteTopics = Set(preferences.favoriteTopics.keys)
        let contentTopics = Set(content.extractedTopics.map { $0.name })
        if !favoriteTopics.isDisjoint(with: contentTopics) {
            relevance += 0.2
        }

        // Boost if watched completely
        if content.wasCompleted {
            relevance += 0.1
        }

        return min(relevance, 1.0)
    }
}

// MARK: - Supporting Types

public struct MusicStats: Sendable {
    public let totalTracks: Int
    public let totalPlayCount: Int
    public let totalListeningTime: TimeInterval
    public let mostPlayedTracks: [MusicTrack]
    public let topGenres: [String]
    public let topArtists: [String]
    public let likedCount: Int
    public let moodDistribution: [String: Int]

    public var formattedListeningTime: String {
        let hours = Int(totalListeningTime / 3600)
        let minutes = Int((totalListeningTime.truncatingRemainder(dividingBy: 3600)) / 60)
        return "\(hours)h \(minutes)m"
    }
}

public struct ViewingPatterns: Sendable {
    public let byHour: [Int: TimeInterval]
    public let byDayOfWeek: [Int: TimeInterval]
    public let byContentType: [YouTubeContentType: TimeInterval]
    public let peakHour: Int
    public let peakDay: Int

    public var peakHourFormatted: String {
        let formatter = DateFormatter()
        formatter.dateFormat = "ha"
        let date = Calendar.current.date(bySettingHour: peakHour, minute: 0, second: 0, of: Date())!
        return formatter.string(from: date)
    }

    public var peakDayFormatted: String {
        let days = ["", "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
        return days[peakDay]
    }
}
