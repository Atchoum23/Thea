//
//  ArtifactManagerTypes.swift
//  Thea
//
//  Extracted from ArtifactManager.swift for file_length compliance.
//

import CloudKit
import Foundation

// MARK: - Artifact Model

/// An artifact generated by Thea (code, document, visualization, or data) with version tracking and CloudKit sync.
public struct Artifact: Identifiable, Codable, Sendable {
    public let id: UUID
    public var title: String
    public let type: ArtifactType
    public var content: String
    public var description: String?
    public var tags: [String]
    public var conversationId: String?
    public let createdAt: Date
    public var modifiedAt: Date
    public var version: Int
    public var contentPath: String?

    public init(
        id: UUID = UUID(),
        title: String,
        type: ArtifactType,
        content: String,
        description: String? = nil,
        tags: [String] = [],
        conversationId: String? = nil,
        createdAt: Date = Date(),
        modifiedAt: Date = Date(),
        version: Int = 1,
        contentPath: String? = nil
    ) {
        self.id = id
        self.title = title
        self.type = type
        self.content = content
        self.description = description
        self.tags = tags
        self.conversationId = conversationId
        self.createdAt = createdAt
        self.modifiedAt = modifiedAt
        self.version = version
        self.contentPath = contentPath
    }

    init?(from record: CKRecord) {
        guard let idString = record["id"] as? String,
              let id = UUID(uuidString: idString),
              let title = record["title"] as? String,
              let typeString = record["type"] as? String,
              let type = ArtifactType(rawValue: typeString),
              let content = record["content"] as? String
        else {
            return nil
        }

        self.id = id
        self.title = title
        self.type = type
        self.content = content
        description = record["description"] as? String
        tags = record["tags"] as? [String] ?? []
        conversationId = record["conversationId"] as? String
        createdAt = record["createdAt"] as? Date ?? Date()
        modifiedAt = record["modifiedAt"] as? Date ?? Date()
        version = record["version"] as? Int ?? 1
        contentPath = nil
    }

    func toCKRecord() -> CKRecord {
        let recordID = CKRecord.ID(recordName: id.uuidString)
        let record = CKRecord(recordType: "Artifact", recordID: recordID)

        record["id"] = id.uuidString
        record["title"] = title
        record["type"] = type.rawValue
        record["content"] = content
        record["description"] = description
        record["tags"] = tags
        record["conversationId"] = conversationId
        record["createdAt"] = createdAt
        record["modifiedAt"] = modifiedAt
        record["version"] = version

        return record
    }
}

// MARK: - Artifact Types

/// The kind of content an artifact contains, with associated metadata (language, format, visualization type, etc.).
public enum ArtifactType: Codable, Sendable, Hashable {
    case code(language: CodeLanguage)
    case document(format: DocumentFormat)
    case visualization(type: VisualizationType)
    case interactive
    case data(format: DataFormat)

    public var category: String {
        switch self {
        case .code: "code"
        case .document: "document"
        case .visualization: "visualization"
        case .interactive: "interactive"
        case .data: "data"
        }
    }

    public var displayName: String {
        switch self {
        case let .code(language): "Code (\(language.displayName))"
        case let .document(format): "Document (\(format.displayName))"
        case let .visualization(type): "Visualization (\(type.displayName))"
        case .interactive: "Interactive"
        case let .data(format): "Data (\(format.displayName))"
        }
    }

    public var fileExtension: String {
        switch self {
        case let .code(language): language.fileExtension
        case let .document(format): format.fileExtension
        case .visualization: "svg"
        case .interactive: "html"
        case let .data(format): format.fileExtension
        }
    }

    public var rawValue: String {
        switch self {
        case let .code(language): "code:\(language.rawValue)"
        case let .document(format): "document:\(format.rawValue)"
        case let .visualization(type): "visualization:\(type.rawValue)"
        case .interactive: "interactive"
        case let .data(format): "data:\(format.rawValue)"
        }
    }

    public init?(rawValue: String) {
        let parts = rawValue.split(separator: ":")
        guard let category = parts.first else { return nil }

        switch category {
        case "code":
            guard parts.count > 1,
                  let language = CodeLanguage(rawValue: String(parts[1])) else { return nil }
            self = .code(language: language)
        case "document":
            guard parts.count > 1,
                  let format = DocumentFormat(rawValue: String(parts[1])) else { return nil }
            self = .document(format: format)
        case "visualization":
            guard parts.count > 1,
                  let type = VisualizationType(rawValue: String(parts[1])) else { return nil }
            self = .visualization(type: type)
        case "interactive":
            self = .interactive
        case "data":
            guard parts.count > 1,
                  let format = DataFormat(rawValue: String(parts[1])) else { return nil }
            self = .data(format: format)
        default:
            return nil
        }
    }
}

/// Programming or markup language used by a code artifact.
public enum CodeLanguage: String, Codable, Sendable, CaseIterable {
    case swift, python, javascript, typescript, java, kotlin, rust, go, cpp, csharp
    case html, css, sql, bash, ruby, php, scala, haskell, elixir, clojure

    public var displayName: String {
        switch self {
        case .swift: "Swift"
        case .python: "Python"
        case .javascript: "JavaScript"
        case .typescript: "TypeScript"
        case .java: "Java"
        case .kotlin: "Kotlin"
        case .rust: "Rust"
        case .go: "Go"
        case .cpp: "C++"
        case .csharp: "C#"
        case .html: "HTML"
        case .css: "CSS"
        case .sql: "SQL"
        case .bash: "Bash"
        case .ruby: "Ruby"
        case .php: "PHP"
        case .scala: "Scala"
        case .haskell: "Haskell"
        case .elixir: "Elixir"
        case .clojure: "Clojure"
        }
    }

    public var fileExtension: String {
        switch self {
        case .swift: "swift"
        case .python: "py"
        case .javascript: "js"
        case .typescript: "ts"
        case .java: "java"
        case .kotlin: "kt"
        case .rust: "rs"
        case .go: "go"
        case .cpp: "cpp"
        case .csharp: "cs"
        case .html: "html"
        case .css: "css"
        case .sql: "sql"
        case .bash: "sh"
        case .ruby: "rb"
        case .php: "php"
        case .scala: "scala"
        case .haskell: "hs"
        case .elixir: "ex"
        case .clojure: "clj"
        }
    }
}

/// Supported document formats for document artifacts.
public enum DocumentFormat: String, Codable, Sendable, CaseIterable {
    case markdown, plainText, html, latex, rst

    public var displayName: String {
        switch self {
        case .markdown: "Markdown"
        case .plainText: "Plain Text"
        case .html: "HTML"
        case .latex: "LaTeX"
        case .rst: "reStructuredText"
        }
    }

    public var fileExtension: String {
        switch self {
        case .markdown: "md"
        case .plainText: "txt"
        case .html: "html"
        case .latex: "tex"
        case .rst: "rst"
        }
    }
}

/// Categories of visual artifact (chart, diagram, graph, etc.).
public enum VisualizationType: String, Codable, Sendable, CaseIterable {
    case svg, chart, diagram, flowchart, mindmap

    public var displayName: String {
        switch self {
        case .svg: "SVG"
        case .chart: "Chart"
        case .diagram: "Diagram"
        case .flowchart: "Flowchart"
        case .mindmap: "Mind Map"
        }
    }
}

/// Structured data formats supported for data artifacts.
public enum DataFormat: String, Codable, Sendable, CaseIterable {
    case json, csv, yaml, xml, toml

    public var displayName: String {
        switch self {
        case .json: "JSON"
        case .csv: "CSV"
        case .yaml: "YAML"
        case .xml: "XML"
        case .toml: "TOML"
        }
    }

    public var fileExtension: String {
        rawValue
    }
}

// MARK: - Artifact Error

public enum ArtifactError: Error, LocalizedError, Sendable {
    case notFound
    case saveFailed(String)
    case invalidContent
    case exportFailed(String)

    public var errorDescription: String? {
        switch self {
        case .notFound:
            "Artifact not found"
        case let .saveFailed(reason):
            "Failed to save artifact: \(reason)"
        case .invalidContent:
            "Invalid artifact content"
        case let .exportFailed(reason):
            "Failed to export artifact: \(reason)"
        }
    }
}
