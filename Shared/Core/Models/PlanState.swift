// PlanState.swift
// Thea
//
// Data models for Plan Mode â€” visible, trackable execution plans
// generated by the Meta-AI orchestrator for complex multi-task queries.

import Foundation

// MARK: - Plan Step Status

/// Execution state of a single step within a plan.
public enum PlanStepStatus: String, Codable, Sendable {
    case pending
    case inProgress
    case completed
    case failed
    case skipped
    case modified
}

// MARK: - Plan Step

/// A single unit of work within a plan, tracking status, result, timing, and which model executed it.
public struct PlanStep: Identifiable, Codable, Sendable {
    public let id: UUID
    public var title: String
    public var activeDescription: String
    public var status: PlanStepStatus
    public var subQueryId: UUID?
    public var taskType: String
    public var result: String?
    public var error: String?
    public var startedAt: Date?
    public var completedAt: Date?
    public var modelUsed: String?

    public init(
        id: UUID = UUID(),
        title: String,
        activeDescription: String,
        status: PlanStepStatus = .pending,
        subQueryId: UUID? = nil,
        taskType: String = "general",
        result: String? = nil,
        error: String? = nil,
        startedAt: Date? = nil,
        completedAt: Date? = nil,
        modelUsed: String? = nil
    ) {
        self.id = id
        self.title = title
        self.activeDescription = activeDescription
        self.status = status
        self.subQueryId = subQueryId
        self.taskType = taskType
        self.result = result
        self.error = error
        self.startedAt = startedAt
        self.completedAt = completedAt
        self.modelUsed = modelUsed
    }

    public var duration: TimeInterval? {
        guard let start = startedAt, let end = completedAt else { return nil }
        return end.timeIntervalSince(start)
    }
}

// MARK: - Plan Phase

/// A logical grouping of related steps within a plan.
public struct PlanPhase: Identifiable, Codable, Sendable {
    public let id: UUID
    public var title: String
    public var steps: [PlanStep]

    public init(
        id: UUID = UUID(),
        title: String,
        steps: [PlanStep]
    ) {
        self.id = id
        self.title = title
        self.steps = steps
    }

    public var completedSteps: Int {
        steps.filter { $0.status == .completed }.count
    }

    public var totalSteps: Int { steps.count }

    public var isComplete: Bool {
        steps.allSatisfy { $0.status == .completed || $0.status == .skipped }
    }

    public var currentStep: PlanStep? {
        steps.first { $0.status == .inProgress }
    }

    public var progress: Double {
        guard totalSteps > 0 else { return 0 }
        return Double(completedSteps) / Double(totalSteps)
    }
}

// MARK: - Plan Status

/// Overall lifecycle status of an execution plan.
public enum PlanStatus: String, Codable, Sendable {
    case creating
    case executing
    case paused
    case completed
    case failed
    case cancelled
    case modifying

    public var displayName: String {
        switch self {
        case .creating: "Creating plan..."
        case .executing: "Executing"
        case .paused: "Paused"
        case .completed: "Completed"
        case .failed: "Failed"
        case .cancelled: "Cancelled"
        case .modifying: "Updating plan..."
        }
    }
}

// MARK: - Plan State

/// The complete state of an AI-generated execution plan, including phases, steps, and progress metrics.
public struct PlanState: Identifiable, Codable, Sendable {
    public let id: UUID
    public var title: String
    public var phases: [PlanPhase]
    public var status: PlanStatus
    public var conversationId: UUID?
    public var createdAt: Date
    public var updatedAt: Date
    public var originalQuery: String

    public init(
        id: UUID = UUID(),
        title: String,
        phases: [PlanPhase],
        status: PlanStatus = .creating,
        conversationId: UUID? = nil,
        createdAt: Date = Date(),
        updatedAt: Date = Date(),
        originalQuery: String
    ) {
        self.id = id
        self.title = title
        self.phases = phases
        self.status = status
        self.conversationId = conversationId
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.originalQuery = originalQuery
    }

    public var totalSteps: Int {
        phases.flatMap(\.steps).count
    }

    public var completedSteps: Int {
        phases.flatMap(\.steps).filter { $0.status == .completed }.count
    }

    public var progress: Double {
        guard totalSteps > 0 else { return 0 }
        return Double(completedSteps) / Double(totalSteps)
    }

    public var currentStepTitle: String? {
        phases.flatMap(\.steps).first { $0.status == .inProgress }?.activeDescription
    }

    public var isActive: Bool {
        status == .executing || status == .creating || status == .modifying
    }
}

// MARK: - Plan Modification

public struct PlanModification: Sendable {
    public enum ModificationType: Sendable {
        case insertSteps([PlanStep], afterStepId: UUID?)
        case removeSteps([UUID])
        case updateStep(UUID, newTitle: String?, newDescription: String?)
        case reorderPhases([UUID])
        case addPhase(PlanPhase, atIndex: Int)
    }

    public let type: ModificationType
    public let reason: String

    public init(type: ModificationType, reason: String) {
        self.type = type
        self.reason = reason
    }
}
