//
//  MCPServerGenerator.swift
//  Thea
//
//  Created by Claude Code on 2026-01-20
//  Copyright Â© 2026. All rights reserved.
//

import Foundation

// MARK: - MCP Server Generator

/// Generates Model Context Protocol (MCP) server implementations
public actor MCPServerGenerator {
    public static let shared = MCPServerGenerator()

    // MARK: - State

    private var generatedServers: [String: GeneratedMCPServer] = [:]
    private var templates: [String: MCPTemplate] = [:]
    private var isInitialized = false

    // MARK: - Initialization

    private init() {
        // Templates are loaded lazily on first use
    }

    /// Initialize default templates (call before first use)
    public func initialize() {
        guard !isInitialized else { return }
        loadDefaultTemplates()
        isInitialized = true
    }

    // MARK: - Server Generation

    /// Generate an MCP server from a specification
    public func generateServer(from spec: MCPServerSpec) async throws -> GeneratedMCPServer {
        var code = """
        //
        //  \(spec.name)MCPServer.swift
        //  Generated by Thea MCP Builder
        //
        //  Created on \(ISO8601DateFormatter().string(from: Date()))
        //

        import Foundation

        // MARK: - \(spec.name) MCP Server

        """

        // Generate protocol definition
        code += generateProtocol(for: spec)

        // Generate server implementation
        code += generateServerClass(for: spec)

        // Generate tool handlers
        for tool in spec.tools {
            code += generateToolHandler(tool, serverName: spec.name)
        }

        // Generate resource handlers
        for resource in spec.resources {
            code += generateResourceHandler(resource, serverName: spec.name)
        }

        // Generate prompt handlers
        for prompt in spec.prompts {
            code += generatePromptHandler(prompt, serverName: spec.name)
        }

        let server = GeneratedMCPServer(
            id: UUID().uuidString,
            name: spec.name,
            spec: spec,
            generatedCode: code,
            generatedAt: Date()
        )

        generatedServers[server.id] = server
        return server
    }

    /// Generate server from template
    public func generateFromTemplate(_ templateName: String, config: MCPTemplateConfig) async throws -> GeneratedMCPServer {
        guard let template = templates[templateName] else {
            throw MCPGeneratorError.templateNotFound(templateName)
        }

        let spec = template.createSpec(with: config)
        return try await generateServer(from: spec)
    }

    // MARK: - Code Generation Helpers

    private func generateProtocol(for spec: MCPServerSpec) -> String {
        var code = """

        // MARK: - Protocol

        public protocol \(spec.name)MCPServerProtocol: MCPServer {

        """

        for tool in spec.tools {
            let params = tool.parameters.map { "\($0.name): \($0.swiftType)" }.joined(separator: ", ")
            code += "    func \(tool.name)(\(params)) async throws -> MCPToolResult\n"
        }

        code += "}\n\n"
        return code
    }

    private func generateServerClass(for spec: MCPServerSpec) -> String {
        var code = """

        // MARK: - Server Implementation

        public actor \(spec.name)MCPServer: \(spec.name)MCPServerProtocol {
            public let serverInfo: MCPServerInfo

            // MARK: - State

            private var isRunning = false
            private var connections: [MCPConnection] = []

            // MARK: - Initialization

            public init() {
                self.serverInfo = MCPServerInfo(
                    name: "\(spec.name)",
                    version: "\(spec.version)",
                    capabilities: MCPCapabilities(
                        tools: \(spec.tools.isEmpty ? "nil" : "MCPToolsCapability()"),
                        resources: \(spec.resources.isEmpty ? "nil" : "MCPResourcesCapability()"),
                        prompts: \(spec.prompts.isEmpty ? "nil" : "MCPPromptsCapability()")
                    )
                )
            }

            // MARK: - Lifecycle

            public func start() async throws {
                guard !isRunning else { return }
                isRunning = true
            }

            public func stop() async {
                isRunning = false
                connections.removeAll()
            }

            // MARK: - Connection Handling

            public func handleConnection(_ connection: MCPConnection) async {
                connections.append(connection)
            }

            public func handleDisconnection(_ connectionId: String) async {
                connections.removeAll { $0.id == connectionId }
            }

            // MARK: - Request Handling

            public func handleRequest(_ request: MCPRequest) async throws -> MCPResponse {
                switch request.method {
                case "initialize":
                    return try await handleInitialize(request)
                case "tools/list":
                    return try await handleListTools(request)
                case "tools/call":
                    return try await handleCallTool(request)
                case "resources/list":
                    return try await handleListResources(request)
                case "resources/read":
                    return try await handleReadResource(request)
                case "prompts/list":
                    return try await handleListPrompts(request)
                case "prompts/get":
                    return try await handleGetPrompt(request)
                default:
                    throw MCPError.methodNotFound(request.method)
                }
            }

            // MARK: - Initialize Handler

            private func handleInitialize(_ request: MCPRequest) async throws -> MCPResponse {
                MCPResponse(
                    id: request.id,
                    result: [
                        "protocolVersion": "2024-11-05",
                        "capabilities": serverInfo.capabilities.dictionary,
                        "serverInfo": [
                            "name": serverInfo.name,
                            "version": serverInfo.version
                        ]
                    ]
                )
            }


        """

        return code
    }

    private func generateToolHandler(_ tool: MCPToolSpec, serverName: String) -> String {
        let paramExtraction = tool.parameters.map { param in
            "let \(param.name) = params[\"\(param.name)\"] as\(param.isRequired ? "!" : "?") \(param.swiftType)"
        }.joined(separator: "\n            ")

        return """

            // MARK: - \(tool.name) Tool

            public func \(tool.name)(\(tool.parameters.map { "\($0.name): \($0.swiftType)" }.joined(separator: ", "))) async throws -> MCPToolResult {
                // TODO: Implement \(tool.name) logic
                return MCPToolResult(
                    content: [MCPContent(type: "text", text: "Result from \(tool.name)")],
                    isError: false
                )
            }

            private func handle\(tool.name.capitalized)(_ params: [String: Any]) async throws -> MCPToolResult {
                \(paramExtraction.isEmpty ? "// No parameters" : paramExtraction)
                return try await \(tool.name)(\(tool.parameters.map { "\($0.name): \($0.name)" }.joined(separator: ", ")))
            }

        """
    }

    private func generateResourceHandler(_ resource: MCPResourceSpec, serverName: String) -> String {
        """

            // MARK: - \(resource.name) Resource

            private func read\(resource.name.capitalized)Resource(uri: String) async throws -> MCPResourceContent {
                // TODO: Implement resource reading logic
                return MCPResourceContent(
                    uri: uri,
                    mimeType: "\(resource.mimeType)",
                    text: "Resource content"
                )
            }

        """
    }

    private func generatePromptHandler(_ prompt: MCPPromptSpec, serverName: String) -> String {
        """

            // MARK: - \(prompt.name) Prompt

            private func get\(prompt.name.capitalized)Prompt(arguments: [String: String]) async throws -> MCPPromptResult {
                // TODO: Implement prompt generation logic
                return MCPPromptResult(
                    description: "\(prompt.description)",
                    messages: [
                        MCPPromptMessage(role: "user", content: MCPContent(type: "text", text: "Generated prompt"))
                    ]
                )
            }

        """
    }

    // MARK: - List Handlers Generation

    private func generateListHandlers(for spec: MCPServerSpec) -> String {
        var code = """

            // MARK: - List Handlers

            private func handleListTools(_ request: MCPRequest) async throws -> MCPResponse {
                let tools: [[String: Any]] = [

        """

        for tool in spec.tools {
            code += """
                        [
                            "name": "\(tool.name)",
                            "description": "\(tool.description)",
                            "inputSchema": \(generateInputSchema(tool.parameters))
                        ],

            """
        }

        code += """
                ]
                return MCPResponse(id: request.id, result: ["tools": tools])
            }

            private func handleCallTool(_ request: MCPRequest) async throws -> MCPResponse {
                guard let params = request.params,
                      let name = params["name"] as? String,
                      let arguments = params["arguments"] as? [String: Any] else {
                    throw MCPError.invalidParams("Missing tool name or arguments")
                }

                let result: MCPToolResult
                switch name {

        """

        for tool in spec.tools {
            code += """
                    case "\(tool.name)":
                        result = try await handle\(tool.name.capitalized)(arguments)

            """
        }

        code += """
                    default:
                        throw MCPError.toolNotFound(name)
                }

                return MCPResponse(id: request.id, result: result.dictionary)
            }

        """

        return code
    }

    private func generateInputSchema(_ parameters: [MCPParameterSpec]) -> String {
        var schema: [String: Any] = [
            "type": "object",
            "properties": [:],
            "required": parameters.filter(\.isRequired).map(\.name)
        ]

        var properties: [String: [String: String]] = [:]
        for param in parameters {
            properties[param.name] = [
                "type": param.jsonType,
                "description": param.description
            ]
        }
        schema["properties"] = properties

        // Convert to JSON string representation
        if let data = try? JSONSerialization.data(withJSONObject: schema),
           let string = String(data: data, encoding: .utf8) {
            return string
        }
        return "{}"
    }

    // MARK: - Template Management

    private func loadDefaultTemplates() {
        // File operations template
        templates["file-operations"] = MCPTemplate(
            name: "file-operations",
            description: "File system operations server",
            defaultTools: [
                MCPToolSpec(
                    name: "readFile",
                    description: "Read contents of a file",
                    parameters: [
                        MCPParameterSpec(name: "path", type: .string, description: "File path", isRequired: true)
                    ]
                ),
                MCPToolSpec(
                    name: "writeFile",
                    description: "Write contents to a file",
                    parameters: [
                        MCPParameterSpec(name: "path", type: .string, description: "File path", isRequired: true),
                        MCPParameterSpec(name: "content", type: .string, description: "Content to write", isRequired: true)
                    ]
                ),
                MCPToolSpec(
                    name: "listDirectory",
                    description: "List directory contents",
                    parameters: [
                        MCPParameterSpec(name: "path", type: .string, description: "Directory path", isRequired: true)
                    ]
                )
            ]
        )

        // Database operations template
        templates["database"] = MCPTemplate(
            name: "database",
            description: "Database operations server",
            defaultTools: [
                MCPToolSpec(
                    name: "query",
                    description: "Execute a database query",
                    parameters: [
                        MCPParameterSpec(name: "sql", type: .string, description: "SQL query", isRequired: true)
                    ]
                ),
                MCPToolSpec(
                    name: "insert",
                    description: "Insert a record",
                    parameters: [
                        MCPParameterSpec(name: "table", type: .string, description: "Table name", isRequired: true),
                        MCPParameterSpec(name: "data", type: .object, description: "Data to insert", isRequired: true)
                    ]
                )
            ]
        )

        // API proxy template
        templates["api-proxy"] = MCPTemplate(
            name: "api-proxy",
            description: "HTTP API proxy server",
            defaultTools: [
                MCPToolSpec(
                    name: "httpGet",
                    description: "Make HTTP GET request",
                    parameters: [
                        MCPParameterSpec(name: "url", type: .string, description: "Request URL", isRequired: true),
                        MCPParameterSpec(name: "headers", type: .object, description: "Request headers", isRequired: false)
                    ]
                ),
                MCPToolSpec(
                    name: "httpPost",
                    description: "Make HTTP POST request",
                    parameters: [
                        MCPParameterSpec(name: "url", type: .string, description: "Request URL", isRequired: true),
                        MCPParameterSpec(name: "body", type: .object, description: "Request body", isRequired: true),
                        MCPParameterSpec(name: "headers", type: .object, description: "Request headers", isRequired: false)
                    ]
                )
            ]
        )
    }

    /// Get available templates
    public func getAvailableTemplates() -> [MCPTemplate] {
        Array(templates.values)
    }

    /// Get generated server by ID
    public func getGeneratedServer(_ id: String) -> GeneratedMCPServer? {
        generatedServers[id]
    }

    /// Export generated server to file
    public func exportServer(_ id: String, to directory: URL) async throws -> URL {
        guard let server = generatedServers[id] else {
            throw MCPGeneratorError.serverNotFound(id)
        }

        let fileName = "\(server.name)MCPServer.swift"
        let fileURL = directory.appendingPathComponent(fileName)

        try server.generatedCode.write(to: fileURL, atomically: true, encoding: .utf8)
        return fileURL
    }
}

// MARK: - MCP Server Spec

public struct MCPServerSpec: Codable, Sendable {
    public let name: String
    public let version: String
    public let description: String
    public var tools: [MCPToolSpec]
    public var resources: [MCPResourceSpec]
    public var prompts: [MCPPromptSpec]

    public init(
        name: String,
        version: String = "1.0.0",
        description: String = "",
        tools: [MCPToolSpec] = [],
        resources: [MCPResourceSpec] = [],
        prompts: [MCPPromptSpec] = []
    ) {
        self.name = name
        self.version = version
        self.description = description
        self.tools = tools
        self.resources = resources
        self.prompts = prompts
    }
}

// MARK: - MCP Tool Spec

public struct MCPToolSpec: Codable, Sendable, Identifiable {
    public var id: String { name }
    public let name: String
    public let description: String
    public let parameters: [MCPParameterSpec]

    public init(name: String, description: String, parameters: [MCPParameterSpec] = []) {
        self.name = name
        self.description = description
        self.parameters = parameters
    }
}

// MARK: - MCP Parameter Spec

public struct MCPParameterSpec: Codable, Sendable {
    public let name: String
    public let type: MCPParameterType
    public let description: String
    public let isRequired: Bool

    public init(name: String, type: MCPParameterType, description: String, isRequired: Bool = true) {
        self.name = name
        self.type = type
        self.description = description
        self.isRequired = isRequired
    }

    public var swiftType: String {
        let baseType: String
        switch type {
        case .string: baseType = "String"
        case .number: baseType = "Double"
        case .integer: baseType = "Int"
        case .boolean: baseType = "Bool"
        case .array: baseType = "[Any]"
        case .object: baseType = "[String: Any]"
        }
        return isRequired ? baseType : "\(baseType)?"
    }

    public var jsonType: String {
        switch type {
        case .string: return "string"
        case .number: return "number"
        case .integer: return "integer"
        case .boolean: return "boolean"
        case .array: return "array"
        case .object: return "object"
        }
    }
}

// MARK: - MCP Parameter Type

public enum MCPParameterType: String, Codable, Sendable {
    case string
    case number
    case integer
    case boolean
    case array
    case object
}

// MARK: - MCP Resource Spec

public struct MCPResourceSpec: Codable, Sendable, Identifiable {
    public var id: String { name }
    public let name: String
    public let description: String
    public let uriTemplate: String
    public let mimeType: String

    public init(name: String, description: String, uriTemplate: String, mimeType: String = "text/plain") {
        self.name = name
        self.description = description
        self.uriTemplate = uriTemplate
        self.mimeType = mimeType
    }
}

// MARK: - MCP Prompt Spec

public struct MCPPromptSpec: Codable, Sendable, Identifiable {
    public var id: String { name }
    public let name: String
    public let description: String
    public let arguments: [MCPArgumentSpec]

    public init(name: String, description: String, arguments: [MCPArgumentSpec] = []) {
        self.name = name
        self.description = description
        self.arguments = arguments
    }
}

// MARK: - MCP Argument Spec

public struct MCPArgumentSpec: Codable, Sendable {
    public let name: String
    public let description: String
    public let isRequired: Bool

    public init(name: String, description: String, isRequired: Bool = true) {
        self.name = name
        self.description = description
        self.isRequired = isRequired
    }
}

// MARK: - Generated MCP Server

public struct GeneratedMCPServer: Sendable, Identifiable {
    public let id: String
    public let name: String
    public let spec: MCPServerSpec
    public let generatedCode: String
    public let generatedAt: Date
}

// MARK: - MCP Template

public struct MCPTemplate: Sendable {
    public let name: String
    public let description: String
    public let defaultTools: [MCPToolSpec]
    public var defaultResources: [MCPResourceSpec] = []
    public var defaultPrompts: [MCPPromptSpec] = []

    public func createSpec(with config: MCPTemplateConfig) -> MCPServerSpec {
        MCPServerSpec(
            name: config.serverName,
            version: config.version,
            description: config.description ?? description,
            tools: config.includeDefaultTools ? defaultTools : [],
            resources: config.includeDefaultResources ? defaultResources : [],
            prompts: config.includeDefaultPrompts ? defaultPrompts : []
        )
    }
}

// MARK: - MCP Template Config

public struct MCPTemplateConfig: Sendable {
    public let serverName: String
    public var version: String = "1.0.0"
    public var description: String?
    public var includeDefaultTools: Bool = true
    public var includeDefaultResources: Bool = true
    public var includeDefaultPrompts: Bool = true

    public init(serverName: String) {
        self.serverName = serverName
    }
}

// MARK: - MCP Generator Error

public enum MCPGeneratorError: Error, LocalizedError, Sendable {
    case templateNotFound(String)
    case serverNotFound(String)
    case invalidSpec(String)
    case generationFailed(String)

    public var errorDescription: String? {
        switch self {
        case .templateNotFound(let name):
            return "Template not found: \(name)"
        case .serverNotFound(let id):
            return "Generated server not found: \(id)"
        case .invalidSpec(let reason):
            return "Invalid specification: \(reason)"
        case .generationFailed(let reason):
            return "Code generation failed: \(reason)"
        }
    }
}

// MARK: - MCP Protocol Types

public protocol MCPServer: Actor {
    var serverMetadata: MCPServerMetadata { get }
    func start() async throws
    func stop() async
    func handleRequest(_ request: MCPRequest) async throws -> MCPResponse
}

public struct MCPServerMetadata: Sendable {
    public let name: String
    public let version: String
    public let capabilities: MCPCapabilities

    public init(name: String, version: String, capabilities: MCPCapabilities) {
        self.name = name
        self.version = version
        self.capabilities = capabilities
    }
}

public struct MCPCapabilities: Sendable {
    public let tools: MCPToolsCapability?
    public let resources: MCPResourcesCapability?
    public let prompts: MCPPromptsCapability?

    public var dictionary: [String: Any] {
        var dict: [String: Any] = [:]
        if tools != nil { dict["tools"] = [:] }
        if resources != nil { dict["resources"] = [:] }
        if prompts != nil { dict["prompts"] = [:] }
        return dict
    }

    public init(tools: MCPToolsCapability? = nil, resources: MCPResourcesCapability? = nil, prompts: MCPPromptsCapability? = nil) {
        self.tools = tools
        self.resources = resources
        self.prompts = prompts
    }
}

public struct MCPToolsCapability: Sendable {}
public struct MCPResourcesCapability: Sendable {}
public struct MCPPromptsCapability: Sendable {}

public struct MCPConnection: Sendable, Identifiable {
    public let id: String
    public let connectedAt: Date

    public init(id: String = UUID().uuidString, connectedAt: Date = Date()) {
        self.id = id
        self.connectedAt = connectedAt
    }
}

public struct MCPRequest: @unchecked Sendable {
    public let id: String
    public let method: String
    public let params: [String: Any]?

    public init(id: String, method: String, params: [String: Any]? = nil) {
        self.id = id
        self.method = method
        self.params = params
    }
}

public struct MCPResponse: @unchecked Sendable {
    public let id: String
    public let result: [String: Any]?
    public let error: MCPError?

    public init(id: String, result: [String: Any]? = nil, error: MCPError? = nil) {
        self.id = id
        self.result = result
        self.error = error
    }
}

public struct MCPToolResult: Sendable {
    public let content: [MCPContent]
    public let isError: Bool

    public var dictionary: [String: Any] {
        [
            "content": content.map { ["type": $0.type, "text": $0.text ?? ""] },
            "isError": isError
        ]
    }

    public init(content: [MCPContent], isError: Bool = false) {
        self.content = content
        self.isError = isError
    }
}

public struct MCPContent: Sendable {
    public let type: String
    public let text: String?

    public init(type: String, text: String? = nil) {
        self.type = type
        self.text = text
    }
}

public struct MCPResourceContent: Sendable {
    public let uri: String
    public let mimeType: String
    public let text: String?

    public init(uri: String, mimeType: String, text: String? = nil) {
        self.uri = uri
        self.mimeType = mimeType
        self.text = text
    }
}

public struct MCPPromptResult: Sendable {
    public let description: String
    public let messages: [MCPPromptMessage]

    public init(description: String, messages: [MCPPromptMessage]) {
        self.description = description
        self.messages = messages
    }
}

public struct MCPPromptMessage: Sendable {
    public let role: String
    public let content: MCPContent

    public init(role: String, content: MCPContent) {
        self.role = role
        self.content = content
    }
}

public enum MCPError: Error, LocalizedError, Sendable {
    case methodNotFound(String)
    case invalidParams(String)
    case toolNotFound(String)
    case resourceNotFound(String)
    case promptNotFound(String)
    case internalError(String)

    public var errorDescription: String? {
        switch self {
        case .methodNotFound(let method):
            return "Method not found: \(method)"
        case .invalidParams(let reason):
            return "Invalid parameters: \(reason)"
        case .toolNotFound(let name):
            return "Tool not found: \(name)"
        case .resourceNotFound(let uri):
            return "Resource not found: \(uri)"
        case .promptNotFound(let name):
            return "Prompt not found: \(name)"
        case .internalError(let reason):
            return "Internal error: \(reason)"
        }
    }
}
