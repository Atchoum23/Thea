//
//  MCPServerGenerator.swift
//  Thea
//
//  Created by Claude Code on 2026-01-20
//  Copyright Â© 2026. All rights reserved.
//

import Foundation
import OSLog

// MARK: - MCP Server Generator

/// Generates Model Context Protocol (MCP) server implementations
public actor MCPServerGenerator {
    public static let shared = MCPServerGenerator()

    // MARK: - State

    private let mcpGeneratorLogger = Logger(subsystem: "ai.thea.app", category: "MCPServerGenerator")
    private var generatedServers: [String: GeneratedMCPServer] = [:]
    private var templates: [String: MCPTemplate] = [:]
    private var isInitialized = false

    // MARK: - Initialization

    private init() {
        // Templates are loaded lazily on first use
    }

    /// Initialize default templates (call before first use)
    public func initialize() {
        guard !isInitialized else { return }
        loadDefaultTemplates()
        isInitialized = true
    }

    // MARK: - Server Generation

    /// Generate an MCP server from a specification
    public func generateServer(from spec: MCPServerSpec) async throws -> GeneratedMCPServer {
        var code = """
        //
        //  \(spec.name)MCPServer.swift
        //  Generated by Thea MCP Builder
        //
        //  Created on \(ISO8601DateFormatter().string(from: Date()))
        //

        import Foundation

        // MARK: - \(spec.name) MCP Server

        """

        // Generate protocol definition
        code += generateProtocol(for: spec)

        // Generate server implementation
        code += generateServerClass(for: spec)

        // Generate tool handlers
        for tool in spec.tools {
            code += generateToolHandler(tool, serverName: spec.name)
        }

        // Generate resource handlers
        for resource in spec.resources {
            code += generateResourceHandler(resource, serverName: spec.name)
        }

        // Generate prompt handlers
        for prompt in spec.prompts {
            code += generatePromptHandler(prompt, serverName: spec.name)
        }

        let server = GeneratedMCPServer(
            id: UUID().uuidString,
            name: spec.name,
            spec: spec,
            generatedCode: code,
            generatedAt: Date()
        )

        generatedServers[server.id] = server
        return server
    }

    /// Generate server from template
    public func generateFromTemplate(_ templateName: String, config: MCPTemplateConfig) async throws -> GeneratedMCPServer {
        guard let template = templates[templateName] else {
            throw MCPGeneratorError.templateNotFound(templateName)
        }

        let spec = template.createSpec(with: config)
        return try await generateServer(from: spec)
    }

    // MARK: - Code Generation Helpers

    private func generateProtocol(for spec: MCPServerSpec) -> String {
        var code = """

        // MARK: - Protocol

        public protocol \(spec.name)MCPServerProtocol: MCPServer {

        """

        for tool in spec.tools {
            let params = tool.parameters.map { "\($0.name): \($0.swiftType)" }.joined(separator: ", ")
            code += "    func \(tool.name)(\(params)) async throws -> MCPToolResult\n"
        }

        code += "}\n\n"
        return code
    }

    private func generateServerClass(for spec: MCPServerSpec) -> String {
        generateServerHeader(for: spec) + generateServerRequestHandler() + generateServerInitializeHandler(for: spec)
    }

    private func generateServerHeader(for spec: MCPServerSpec) -> String {
        """

        // MARK: - Server Implementation

        public actor \(spec.name)MCPServer: \(spec.name)MCPServerProtocol {
            public let serverInfo: MCPServerInfo

            // MARK: - State

            private var isRunning = false
            private var connections: [MCPConnection] = []

            // MARK: - Initialization

            public init() {
                self.serverInfo = MCPServerInfo(
                    name: "\(spec.name)",
                    version: "\(spec.version)",
                    capabilities: MCPCapabilities(
                        tools: \(spec.tools.isEmpty ? "nil" : "MCPToolsCapability()"),
                        resources: \(spec.resources.isEmpty ? "nil" : "MCPResourcesCapability()"),
                        prompts: \(spec.prompts.isEmpty ? "nil" : "MCPPromptsCapability()")
                    )
                )
            }

            // MARK: - Lifecycle

            public func start() async throws {
                guard !isRunning else { return }
                isRunning = true
            }

            public func stop() async {
                isRunning = false
                connections.removeAll()
            }

            // MARK: - Connection Handling

            public func handleConnection(_ connection: MCPConnection) async {
                connections.append(connection)
            }

            public func handleDisconnection(_ connectionId: String) async {
                connections.removeAll { $0.id == connectionId }
            }

        """
    }

    private func generateServerRequestHandler() -> String {
        """

            // MARK: - Request Handling

            public func handleRequest(_ request: MCPRequest) async throws -> MCPResponse {
                switch request.method {
                case "initialize":
                    return try await handleInitialize(request)
                case "tools/list":
                    return try await handleListTools(request)
                case "tools/call":
                    return try await handleCallTool(request)
                case "resources/list":
                    return try await handleListResources(request)
                case "resources/read":
                    return try await handleReadResource(request)
                case "prompts/list":
                    return try await handleListPrompts(request)
                case "prompts/get":
                    return try await handleGetPrompt(request)
                default:
                    throw MCPError.methodNotFound(request.method)
                }
            }

        """
    }

    private func generateServerInitializeHandler(for spec: MCPServerSpec) -> String {
        """

            // MARK: - Initialize Handler

            private func handleInitialize(_ request: MCPRequest) async throws -> MCPResponse {
                MCPResponse(
                    id: request.id,
                    result: [
                        "protocolVersion": "2024-11-05",
                        "capabilities": serverInfo.capabilities.dictionary,
                        "serverInfo": [
                            "name": serverInfo.name,
                            "version": serverInfo.version
                        ]
                    ]
                )
            }


        """
    }

    private func generateToolHandler(_ tool: MCPToolSpec, serverName _: String) -> String {
        let paramExtraction = tool.parameters.map { param in
            "let \(param.name) = params[\"\(param.name)\"] as\(param.isRequired ? "!" : "?") \(param.swiftType)"
        }.joined(separator: "\n            ")

        return """

            // MARK: - \(tool.name) Tool

            public func \(tool.name)(\(tool.parameters.map { "\($0.name): \($0.swiftType)" }.joined(separator: ", "))) async throws -> MCPToolResult {
                // TODO: Implement \(tool.name) logic
                return MCPToolResult(
                    content: [MCPContent(type: "text", text: "Result from \(tool.name)")],
                    isError: false
                )
            }

            private func handle\(tool.name.capitalized)(_ params: [String: Any]) async throws -> MCPToolResult {
                \(paramExtraction.isEmpty ? "// No parameters" : paramExtraction)
                return try await \(tool.name)(\(tool.parameters.map { "\($0.name): \($0.name)" }.joined(separator: ", ")))
            }

        """
    }

    private func generateResourceHandler(_ resource: MCPResourceSpec, serverName _: String) -> String {
        """

            // MARK: - \(resource.name) Resource

            private func read\(resource.name.capitalized)Resource(uri: String) async throws -> MCPResourceContent {
                // TODO: Implement resource reading logic
                return MCPResourceContent(
                    uri: uri,
                    mimeType: "\(resource.mimeType)",
                    text: "Resource content"
                )
            }

        """
    }

    private func generatePromptHandler(_ prompt: MCPPromptSpec, serverName _: String) -> String {
        """

            // MARK: - \(prompt.name) Prompt

            private func get\(prompt.name.capitalized)Prompt(arguments: [String: String]) async throws -> MCPPromptResult {
                // TODO: Implement prompt generation logic
                return MCPPromptResult(
                    description: "\(prompt.description)",
                    messages: [
                        MCPPromptMessage(role: "user", content: MCPContent(type: "text", text: "Generated prompt"))
                    ]
                )
            }

        """
    }

    // MARK: - List Handlers Generation

    private func generateListHandlers(for spec: MCPServerSpec) -> String {
        var code = """

            // MARK: - List Handlers

            private func handleListTools(_ request: MCPRequest) async throws -> MCPResponse {
                let tools: [[String: Any]] = [

        """

        for tool in spec.tools {
            code += """
                        [
                            "name": "\(tool.name)",
                            "description": "\(tool.description)",
                            "inputSchema": \(generateInputSchema(tool.parameters))
                        ],

            """
        }

        code += """
                ]
                return MCPResponse(id: request.id, result: ["tools": tools])
            }

            private func handleCallTool(_ request: MCPRequest) async throws -> MCPResponse {
                guard let params = request.params,
                      let name = params["name"] as? String,
                      let arguments = params["arguments"] as? [String: Any] else {
                    throw MCPError.invalidParams("Missing tool name or arguments")
                }

                let result: MCPToolResult
                switch name {

        """

        for tool in spec.tools {
            code += """
                    case "\(tool.name)":
                        result = try await handle\(tool.name.capitalized)(arguments)

            """
        }

        code += """
                    default:
                        throw MCPError.toolNotFound(name)
                }

                return MCPResponse(id: request.id, result: result.dictionary)
            }

        """

        return code
    }

    private func generateInputSchema(_ parameters: [MCPParameterSpec]) -> String {
        var schema: [String: Any] = [
            "type": "object",
            "properties": [:],
            "required": parameters.filter(\.isRequired).map(\.name)
        ]

        var properties: [String: [String: String]] = [:]
        for param in parameters {
            properties[param.name] = [
                "type": param.jsonType,
                "description": param.description
            ]
        }
        schema["properties"] = properties

        // Convert to JSON string representation
        do {
            let data = try JSONSerialization.data(withJSONObject: schema)
            if let string = String(data: data, encoding: .utf8) {
                return string
            }
        } catch {
            mcpGeneratorLogger.error("Failed to serialize JSON schema: \(error.localizedDescription)")
        }
        return "{}"
    }

    // MARK: - Template Management

    private func loadDefaultTemplates() {
        loadFileOperationsTemplate()
        loadDatabaseTemplate()
        loadAPIProxyTemplate()
    }

    private func loadFileOperationsTemplate() {
        templates["file-operations"] = MCPTemplate(
            name: "file-operations",
            description: "File system operations server",
            defaultTools: [
                MCPToolSpec(
                    name: "readFile",
                    description: "Read contents of a file",
                    parameters: [
                        MCPParameterSpec(name: "path", type: .string, description: "File path", isRequired: true)
                    ]
                ),
                MCPToolSpec(
                    name: "writeFile",
                    description: "Write contents to a file",
                    parameters: [
                        MCPParameterSpec(name: "path", type: .string, description: "File path", isRequired: true),
                        MCPParameterSpec(name: "content", type: .string, description: "Content to write", isRequired: true)
                    ]
                ),
                MCPToolSpec(
                    name: "listDirectory",
                    description: "List directory contents",
                    parameters: [
                        MCPParameterSpec(name: "path", type: .string, description: "Directory path", isRequired: true)
                    ]
                )
            ]
        )
    }

    private func loadDatabaseTemplate() {
        templates["database"] = MCPTemplate(
            name: "database",
            description: "Database operations server",
            defaultTools: [
                MCPToolSpec(
                    name: "query",
                    description: "Execute a database query",
                    parameters: [
                        MCPParameterSpec(name: "sql", type: .string, description: "SQL query", isRequired: true)
                    ]
                ),
                MCPToolSpec(
                    name: "insert",
                    description: "Insert a record",
                    parameters: [
                        MCPParameterSpec(name: "table", type: .string, description: "Table name", isRequired: true),
                        MCPParameterSpec(name: "data", type: .object, description: "Data to insert", isRequired: true)
                    ]
                )
            ]
        )
    }

    private func loadAPIProxyTemplate() {
        templates["api-proxy"] = MCPTemplate(
            name: "api-proxy",
            description: "HTTP API proxy server",
            defaultTools: [
                MCPToolSpec(
                    name: "httpGet",
                    description: "Make HTTP GET request",
                    parameters: [
                        MCPParameterSpec(name: "url", type: .string, description: "Request URL", isRequired: true),
                        MCPParameterSpec(name: "headers", type: .object, description: "Request headers", isRequired: false)
                    ]
                ),
                MCPToolSpec(
                    name: "httpPost",
                    description: "Make HTTP POST request",
                    parameters: [
                        MCPParameterSpec(name: "url", type: .string, description: "Request URL", isRequired: true),
                        MCPParameterSpec(name: "body", type: .object, description: "Request body", isRequired: true),
                        MCPParameterSpec(name: "headers", type: .object, description: "Request headers", isRequired: false)
                    ]
                )
            ]
        )
    }

    /// Get available templates
    public func getAvailableTemplates() -> [MCPTemplate] {
        Array(templates.values)
    }

    /// Get generated server by ID
    public func getGeneratedServer(_ id: String) -> GeneratedMCPServer? {
        generatedServers[id]
    }

    /// Export generated server to file
    public func exportServer(_ id: String, to directory: URL) async throws -> URL {
        guard let server = generatedServers[id] else {
            throw MCPGeneratorError.serverNotFound(id)
        }

        let fileName = "\(server.name)MCPServer.swift"
        let fileURL = directory.appendingPathComponent(fileName)

        try server.generatedCode.write(to: fileURL, atomically: true, encoding: .utf8)
        return fileURL
    }
}
// Supporting types are in MCPServerGeneratorTypes.swift
