//
//  APIGenerator.swift
//  Thea
//
//  Created by Claude Code on 2026-01-20
//  Copyright Â© 2026. All rights reserved.
//

import Foundation

// MARK: - API Generator

/// Generates REST API client code from specifications
public actor APIGenerator {
    public static let shared = APIGenerator()

    // MARK: - State

    private var generatedAPIs: [String: GeneratedAPI] = [:]
    private var templates: [String: APITemplate] = [:]

    // MARK: - Initialization

    private init() {
        // Templates are initialized lazily
    }

    /// Initialize default templates - call before first use
    public func initialize() {
        loadDefaultTemplates()
    }

    // MARK: - API Generation

    /// Generate API client from specification
    public func generateAPI(from spec: APISpec) async throws -> GeneratedAPI {
        var code = """
        //
        //  \(spec.name)API.swift
        //  Generated by Thea API Builder
        //
        //  Created on \(ISO8601DateFormatter().string(from: Date()))
        //

        import Foundation

        // MARK: - \(spec.name) API Client

        """

        // Generate models
        for model in spec.models {
            code += generateModel(model)
        }

        // Generate API client
        code += generateAPIClient(for: spec)

        // Generate endpoints
        for endpoint in spec.endpoints {
            code += generateEndpoint(endpoint, apiName: spec.name)
        }

        // Close the class
        code += "}\n"

        let api = GeneratedAPI(
            id: UUID().uuidString,
            name: spec.name,
            spec: spec,
            generatedCode: code,
            generatedAt: Date()
        )

        generatedAPIs[api.id] = api
        return api
    }

    /// Generate API from OpenAPI/Swagger specification
    public func generateFromOpenAPI(_ openAPISpec: Data) async throws -> GeneratedAPI {
        let spec = try parseOpenAPISpec(openAPISpec)
        return try await generateAPI(from: spec)
    }

    /// Generate API from template
    public func generateFromTemplate(_ templateName: String, config: APITemplateConfig) async throws -> GeneratedAPI {
        guard let template = templates[templateName] else {
            throw APIGeneratorError.templateNotFound(templateName)
        }

        let spec = template.createSpec(with: config)
        return try await generateAPI(from: spec)
    }

    // MARK: - Code Generation Helpers

    private func generateModel(_ model: APIModelSpec) -> String {
        var code = """

        // MARK: - \(model.name)

        public struct \(model.name): Codable, Sendable {

        """

        for property in model.properties {
            let type = property.isRequired ? property.swiftType : "\(property.swiftType)?"
            code += "    public var \(property.name): \(type)\n"
        }

        // Generate initializer
        code += "\n    public init(\n"
        let initParams = model.properties.map { prop in
            let defaultValue = prop.isRequired ? "" : " = nil"
            return "        \(prop.name): \(prop.isRequired ? prop.swiftType : "\(prop.swiftType)?")\(defaultValue)"
        }.joined(separator: ",\n")
        code += initParams
        code += "\n    ) {\n"

        for property in model.properties {
            code += "        self.\(property.name) = \(property.name)\n"
        }

        code += "    }\n"

        // Generate CodingKeys if needed
        let needsCodingKeys = model.properties.contains { $0.jsonKey != $0.name }
        if needsCodingKeys {
            code += "\n    private enum CodingKeys: String, CodingKey {\n"
            for property in model.properties {
                if property.jsonKey != property.name {
                    code += "        case \(property.name) = \"\(property.jsonKey)\"\n"
                } else {
                    code += "        case \(property.name)\n"
                }
            }
            code += "    }\n"
        }

        code += "}\n"
        return code
    }

    private func generateAPIClient(for spec: APISpec) -> String {
        """

        // MARK: - \(spec.name) API Client

        public actor \(spec.name)APIClient {
            // MARK: - Configuration

            private let baseURL: URL
            private let session: URLSession
            private var headers: [String: String]

            // MARK: - Initialization

            public init(
                baseURL: URL,
                session: URLSession = .shared,
                headers: [String: String] = [:]
            ) {
                self.baseURL = baseURL
                self.session = session
                self.headers = headers
            }

            // MARK: - Configuration

            public func setHeader(_ value: String, forKey key: String) {
                headers[key] = value
            }

            public func removeHeader(forKey key: String) {
                headers.removeValue(forKey: key)
            }

            public func setAuthToken(_ token: String) {
                headers["Authorization"] = "Bearer \\(token)"
            }

            // MARK: - Request Building

            private func buildRequest(
                path: String,
                method: HTTPMethod,
                queryItems: [URLQueryItem]? = nil,
                body: Data? = nil
            ) throws -> URLRequest {
                var components = URLComponents(url: baseURL.appendingPathComponent(path), resolvingAgainstBaseURL: true)
                components?.queryItems = queryItems

                guard let url = components?.url else {
                    throw APIError.invalidURL(path)
                }

                var request = URLRequest(url: url)
                request.httpMethod = method.rawValue
                request.httpBody = body

                // Add default headers
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                request.setValue("application/json", forHTTPHeaderField: "Accept")

                // Add custom headers
                for (key, value) in headers {
                    request.setValue(value, forHTTPHeaderField: key)
                }

                return request
            }

            // MARK: - Request Execution

            private func execute<T: Decodable>(_ request: URLRequest) async throws -> T {
                let (data, response) = try await session.data(for: request)

                guard let httpResponse = response as? HTTPURLResponse else {
                    throw APIError.invalidResponse
                }

                guard (200...299).contains(httpResponse.statusCode) else {
                    throw APIError.httpError(statusCode: httpResponse.statusCode, data: data)
                }

                let decoder = JSONDecoder()
                decoder.dateDecodingStrategy = .iso8601
                return try decoder.decode(T.self, from: data)
            }

            private func executeVoid(_ request: URLRequest) async throws {
                let (data, response) = try await session.data(for: request)

                guard let httpResponse = response as? HTTPURLResponse else {
                    throw APIError.invalidResponse
                }

                guard (200...299).contains(httpResponse.statusCode) else {
                    throw APIError.httpError(statusCode: httpResponse.statusCode, data: data)
                }
            }

            // MARK: - Endpoints


        """
    }

    private func generateEndpoint(_ endpoint: APIEndpointSpec, apiName: String) -> String {
        var code = """

            /// \(endpoint.description)
            public func \(endpoint.operationId)(

        """

        // Parameters
        var params: [String] = []

        for param in endpoint.pathParameters {
            params.append("\(param.name): \(param.swiftType)")
        }

        for param in endpoint.queryParameters {
            let type = param.isRequired ? param.swiftType : "\(param.swiftType)?"
            let defaultValue = param.isRequired ? "" : " = nil"
            params.append("\(param.name): \(type)\(defaultValue)")
        }

        if let body = endpoint.requestBody {
            params.append("body: \(body.swiftType)")
        }

        code += params.map { "        \($0)" }.joined(separator: ",\n")
        code += "\n    ) async throws"

        // Return type
        if let response = endpoint.responseType {
            code += " -> \(response)"
        }

        code += " {\n"

        // Build path with parameters
        var path = endpoint.path
        for param in endpoint.pathParameters {
            path = path.replacingOccurrences(of: "{\(param.name)}", with: "\\(\(param.name))")
        }

        code += "        let path = \"\(path)\"\n"

        // Query items
        if !endpoint.queryParameters.isEmpty {
            code += "        var queryItems: [URLQueryItem] = []\n"
            for param in endpoint.queryParameters {
                if param.isRequired {
                    code += "        queryItems.append(URLQueryItem(name: \"\(param.name)\", value: String(describing: \(param.name))))\n"
                } else {
                    code += "        if let \(param.name) = \(param.name) {\n"
                    code += "            queryItems.append(URLQueryItem(name: \"\(param.name)\", value: String(describing: \(param.name))))\n"
                    code += "        }\n"
                }
            }
        }

        // Body encoding
        if endpoint.requestBody != nil {
            code += "        let encoder = JSONEncoder()\n"
            code += "        encoder.dateEncodingStrategy = .iso8601\n"
            code += "        let bodyData = try encoder.encode(body)\n"
        }

        // Build and execute request
        let queryParam = endpoint.queryParameters.isEmpty ? "nil" : "queryItems"
        let bodyParam = endpoint.requestBody != nil ? "bodyData" : "nil"

        code += "        let request = try buildRequest(\n"
        code += "            path: path,\n"
        code += "            method: .\(endpoint.method.lowercased()),\n"
        code += "            queryItems: \(queryParam),\n"
        code += "            body: \(bodyParam)\n"
        code += "        )\n"

        if let response = endpoint.responseType {
            code += "        return try await execute(request) as \(response)\n"
        } else {
            code += "        try await executeVoid(request)\n"
        }

        code += "    }\n"
        return code
    }

    // MARK: - OpenAPI Parsing

    private func parseOpenAPISpec(_ data: Data) throws -> APISpec {
        // Parse OpenAPI JSON/YAML
        guard let json = try JSONSerialization.jsonObject(with: data) as? [String: Any] else {
            throw APIGeneratorError.invalidOpenAPISpec("Unable to parse JSON")
        }

        let info = json["info"] as? [String: Any] ?? [:]
        let title = (info["title"] as? String ?? "API").replacingOccurrences(of: " ", with: "")
        let version = info["version"] as? String ?? "1.0.0"

        var spec = APISpec(
            name: title,
            version: version,
            baseURL: parseServers(json["servers"])
        )

        // Parse paths
        if let paths = json["paths"] as? [String: Any] {
            for (path, pathItem) in paths {
                if let methods = pathItem as? [String: Any] {
                    for (method, operation) in methods {
                        if let opDict = operation as? [String: Any],
                           let endpoint = parseEndpoint(path: path, method: method, operation: opDict) {
                            spec.endpoints.append(endpoint)
                        }
                    }
                }
            }
        }

        // Parse components/schemas
        if let components = json["components"] as? [String: Any],
           let schemas = components["schemas"] as? [String: Any] {
            for (name, schema) in schemas {
                if let schemaDict = schema as? [String: Any],
                   let model = parseModel(name: name, schema: schemaDict) {
                    spec.models.append(model)
                }
            }
        }

        return spec
    }

    private func parseServers(_ servers: Any?) -> String {
        guard let serverList = servers as? [[String: Any]],
              let firstServer = serverList.first,
              let url = firstServer["url"] as? String else {
            return "https://api.example.com"
        }
        return url
    }

    private func parseEndpoint(path: String, method: String, operation: [String: Any]) -> APIEndpointSpec? {
        let operationId = operation["operationId"] as? String ?? "\(method)\(path.replacingOccurrences(of: "/", with: "_"))"
        let description = operation["summary"] as? String ?? operation["description"] as? String ?? ""

        var endpoint = APIEndpointSpec(
            path: path,
            method: method.uppercased(),
            operationId: operationId,
            description: description
        )

        // Parse parameters
        if let parameters = operation["parameters"] as? [[String: Any]] {
            for param in parameters {
                if let paramSpec = parseParameter(param) {
                    if param["in"] as? String == "path" {
                        endpoint.pathParameters.append(paramSpec)
                    } else if param["in"] as? String == "query" {
                        endpoint.queryParameters.append(paramSpec)
                    }
                }
            }
        }

        // Parse request body
        if let requestBody = operation["requestBody"] as? [String: Any],
           let content = requestBody["content"] as? [String: Any],
           let jsonContent = content["application/json"] as? [String: Any],
           let schema = jsonContent["schema"] as? [String: Any] {
            endpoint.requestBody = parseBodySpec(schema)
        }

        // Parse response
        if let responses = operation["responses"] as? [String: Any],
           let successResponse = responses["200"] as? [String: Any] ?? responses["201"] as? [String: Any],
           let content = successResponse["content"] as? [String: Any],
           let jsonContent = content["application/json"] as? [String: Any],
           let schema = jsonContent["schema"] as? [String: Any] {
            endpoint.responseType = parseTypeFromSchema(schema)
        }

        return endpoint
    }

    private func parseParameter(_ param: [String: Any]) -> APIParameterSpec? {
        guard let name = param["name"] as? String else { return nil }

        let schema = param["schema"] as? [String: Any] ?? [:]
        let type = parseTypeFromSchema(schema)
        let isRequired = param["required"] as? Bool ?? false
        let description = param["description"] as? String ?? ""

        return APIParameterSpec(
            name: name,
            type: APIPropertyType(rawValue: schema["type"] as? String ?? "string") ?? .string,
            description: description,
            isRequired: isRequired
        )
    }

    private func parseBodySpec(_ schema: [String: Any]) -> APIBodySpec? {
        let type = parseTypeFromSchema(schema)
        return APIBodySpec(swiftType: type)
    }

    private func parseModel(name: String, schema: [String: Any]) -> APIModelSpec? {
        guard let properties = schema["properties"] as? [String: Any] else {
            return nil
        }

        let required = schema["required"] as? [String] ?? []
        var model = APIModelSpec(name: name)

        for (propName, propSchema) in properties {
            if let propDict = propSchema as? [String: Any] {
                let type = APIPropertyType(rawValue: propDict["type"] as? String ?? "string") ?? .string
                let description = propDict["description"] as? String ?? ""

                model.properties.append(APIPropertySpec(
                    name: propName,
                    jsonKey: propName,
                    type: type,
                    description: description,
                    isRequired: required.contains(propName)
                ))
            }
        }

        return model
    }

    private func parseTypeFromSchema(_ schema: [String: Any]) -> String {
        if let ref = schema["$ref"] as? String {
            return ref.components(separatedBy: "/").last ?? "Any"
        }

        let type = schema["type"] as? String ?? "string"
        switch type {
        case "string": return "String"
        case "integer": return "Int"
        case "number": return "Double"
        case "boolean": return "Bool"
        case "array":
            if let items = schema["items"] as? [String: Any] {
                return "[\(parseTypeFromSchema(items))]"
            }
            return "[Any]"
        case "object": return "[String: Any]"
        default: return "Any"
        }
    }

    // MARK: - Template Management

    private func loadDefaultTemplates() {
        // REST CRUD template
        templates["crud"] = APITemplate(
            name: "crud",
            description: "Standard CRUD API",
            defaultEndpoints: [
                APIEndpointSpec(path: "/items", method: "GET", operationId: "listItems", description: "List all items"),
                APIEndpointSpec(path: "/items/{id}", method: "GET", operationId: "getItem", description: "Get item by ID",
                               pathParameters: [APIParameterSpec(name: "id", type: .string, description: "Item ID", isRequired: true)]),
                APIEndpointSpec(path: "/items", method: "POST", operationId: "createItem", description: "Create new item"),
                APIEndpointSpec(path: "/items/{id}", method: "PUT", operationId: "updateItem", description: "Update item",
                               pathParameters: [APIParameterSpec(name: "id", type: .string, description: "Item ID", isRequired: true)]),
                APIEndpointSpec(path: "/items/{id}", method: "DELETE", operationId: "deleteItem", description: "Delete item",
                               pathParameters: [APIParameterSpec(name: "id", type: .string, description: "Item ID", isRequired: true)])
            ]
        )

        // Auth API template
        templates["auth"] = APITemplate(
            name: "auth",
            description: "Authentication API",
            defaultEndpoints: [
                APIEndpointSpec(path: "/auth/login", method: "POST", operationId: "login", description: "User login"),
                APIEndpointSpec(path: "/auth/register", method: "POST", operationId: "register", description: "User registration"),
                APIEndpointSpec(path: "/auth/logout", method: "POST", operationId: "logout", description: "User logout"),
                APIEndpointSpec(path: "/auth/refresh", method: "POST", operationId: "refreshToken", description: "Refresh auth token"),
                APIEndpointSpec(path: "/auth/me", method: "GET", operationId: "getCurrentUser", description: "Get current user")
            ]
        )
    }

    /// Get available templates
    public func getAvailableTemplates() -> [APITemplate] {
        Array(templates.values)
    }

    /// Get generated API by ID
    public func getGeneratedAPI(_ id: String) -> GeneratedAPI? {
        generatedAPIs[id]
    }

    /// Export generated API to file
    public func exportAPI(_ id: String, to directory: URL) async throws -> URL {
        guard let api = generatedAPIs[id] else {
            throw APIGeneratorError.apiNotFound(id)
        }

        let fileName = "\(api.name)API.swift"
        let fileURL = directory.appendingPathComponent(fileName)

        try api.generatedCode.write(to: fileURL, atomically: true, encoding: .utf8)
        return fileURL
    }
}

// MARK: - API Spec

public struct APISpec: Codable, Sendable {
    public let name: String
    public let version: String
    public let baseURL: String
    public var endpoints: [APIEndpointSpec]
    public var models: [APIModelSpec]

    public init(
        name: String,
        version: String = "1.0.0",
        baseURL: String = "https://api.example.com",
        endpoints: [APIEndpointSpec] = [],
        models: [APIModelSpec] = []
    ) {
        self.name = name
        self.version = version
        self.baseURL = baseURL
        self.endpoints = endpoints
        self.models = models
    }
}

// MARK: - API Endpoint Spec

public struct APIEndpointSpec: Codable, Sendable, Identifiable {
    public var id: String { operationId }
    public let path: String
    public let method: String
    public let operationId: String
    public let description: String
    public var pathParameters: [APIParameterSpec]
    public var queryParameters: [APIParameterSpec]
    public var requestBody: APIBodySpec?
    public var responseType: String?

    public init(
        path: String,
        method: String,
        operationId: String,
        description: String,
        pathParameters: [APIParameterSpec] = [],
        queryParameters: [APIParameterSpec] = [],
        requestBody: APIBodySpec? = nil,
        responseType: String? = nil
    ) {
        self.path = path
        self.method = method
        self.operationId = operationId
        self.description = description
        self.pathParameters = pathParameters
        self.queryParameters = queryParameters
        self.requestBody = requestBody
        self.responseType = responseType
    }
}

// MARK: - API Parameter Spec

public struct APIParameterSpec: Codable, Sendable {
    public let name: String
    public let type: APIPropertyType
    public let description: String
    public let isRequired: Bool

    public var swiftType: String {
        type.swiftType
    }

    public init(name: String, type: APIPropertyType, description: String, isRequired: Bool = true) {
        self.name = name
        self.type = type
        self.description = description
        self.isRequired = isRequired
    }
}

// MARK: - API Body Spec

public struct APIBodySpec: Codable, Sendable {
    public let swiftType: String

    public init(swiftType: String) {
        self.swiftType = swiftType
    }
}

// MARK: - API Model Spec

public struct APIModelSpec: Codable, Sendable, Identifiable {
    public var id: String { name }
    public let name: String
    public var properties: [APIPropertySpec]

    public init(name: String, properties: [APIPropertySpec] = []) {
        self.name = name
        self.properties = properties
    }
}

// MARK: - API Property Spec

public struct APIPropertySpec: Codable, Sendable {
    public let name: String
    public let jsonKey: String
    public let type: APIPropertyType
    public let description: String
    public let isRequired: Bool

    public var swiftType: String {
        type.swiftType
    }

    public init(name: String, jsonKey: String? = nil, type: APIPropertyType, description: String = "", isRequired: Bool = true) {
        self.name = name
        self.jsonKey = jsonKey ?? name
        self.type = type
        self.description = description
        self.isRequired = isRequired
    }
}

// MARK: - API Property Type

public enum APIPropertyType: String, Codable, Sendable {
    case string
    case integer
    case number
    case boolean
    case array
    case object

    public var swiftType: String {
        switch self {
        case .string: return "String"
        case .integer: return "Int"
        case .number: return "Double"
        case .boolean: return "Bool"
        case .array: return "[Any]"
        case .object: return "[String: Any]"
        }
    }
}

// MARK: - Generated API

public struct GeneratedAPI: Sendable, Identifiable {
    public let id: String
    public let name: String
    public let spec: APISpec
    public let generatedCode: String
    public let generatedAt: Date
}

// MARK: - API Template

public struct APITemplate: Sendable {
    public let name: String
    public let description: String
    public let defaultEndpoints: [APIEndpointSpec]
    public var defaultModels: [APIModelSpec] = []

    public func createSpec(with config: APITemplateConfig) -> APISpec {
        APISpec(
            name: config.apiName,
            version: config.version,
            baseURL: config.baseURL,
            endpoints: config.includeDefaultEndpoints ? defaultEndpoints : [],
            models: config.includeDefaultModels ? defaultModels : []
        )
    }
}

// MARK: - API Template Config

public struct APITemplateConfig: Sendable {
    public let apiName: String
    public var version: String = "1.0.0"
    public var baseURL: String = "https://api.example.com"
    public var includeDefaultEndpoints: Bool = true
    public var includeDefaultModels: Bool = true

    public init(apiName: String) {
        self.apiName = apiName
    }
}

// MARK: - HTTP Method

public enum HTTPMethod: String, Codable, Sendable {
    case get = "GET"
    case post = "POST"
    case put = "PUT"
    case patch = "PATCH"
    case delete = "DELETE"
    case head = "HEAD"
    case options = "OPTIONS"
}

// MARK: - Generated API Error

public enum GeneratedAPIError: Error, LocalizedError, Sendable {
    case invalidURL(String)
    case invalidResponse
    case httpError(statusCode: Int, data: Data)
    case decodingError(Error)
    case encodingError(Error)
    case networkError(Error)

    public var errorDescription: String? {
        switch self {
        case .invalidURL(let path):
            return "Invalid URL: \(path)"
        case .invalidResponse:
            return "Invalid response from server"
        case .httpError(let statusCode, _):
            return "HTTP error: \(statusCode)"
        case .decodingError(let error):
            return "Decoding error: \(error.localizedDescription)"
        case .encodingError(let error):
            return "Encoding error: \(error.localizedDescription)"
        case .networkError(let error):
            return "Network error: \(error.localizedDescription)"
        }
    }
}

// MARK: - API Generator Error

public enum APIGeneratorError: Error, LocalizedError, Sendable {
    case templateNotFound(String)
    case apiNotFound(String)
    case invalidOpenAPISpec(String)
    case generationFailed(String)

    public var errorDescription: String? {
        switch self {
        case .templateNotFound(let name):
            return "Template not found: \(name)"
        case .apiNotFound(let id):
            return "Generated API not found: \(id)"
        case .invalidOpenAPISpec(let reason):
            return "Invalid OpenAPI specification: \(reason)"
        case .generationFailed(let reason):
            return "Code generation failed: \(reason)"
        }
    }
}
