// ProactivityEngine+Models.swift
// Thea V2 - Proactivity Data Models
//
// All supporting types used by ProactivityEngine and its extensions:
// suggestions, predictions, intent candidates, autonomous actions,
// context watches, and context changes.

import Foundation

// MARK: - Proactive Suggestions

/// A proactive suggestion generated by the ``ProactivityEngine``.
///
/// Note: Distinct from `ProactiveSuggestion` in `MultiModalCoordinator`.
public struct AIProactivitySuggestion: Identifiable, Sendable {
    /// Unique identifier for this suggestion.
    public let id: UUID
    /// Category key used for cooldown and deduplication (e.g. "low_battery", "morning_briefing").
    public let type: String
    /// Short user-facing title.
    public let title: String
    /// Explanation of why this suggestion was generated.
    public let reason: String
    /// Priority level affecting display order and urgency.
    public let priority: EngineSuggestionPriority
    /// When this suggestion was created.
    public let timestamp: Date
    /// Optional key-value payload for downstream action handlers.
    public let actionPayload: [String: String]?

    /// Create a new proactive suggestion.
    ///
    /// - Parameters:
    ///   - id: Unique identifier (defaults to a new UUID).
    ///   - type: Category key for cooldown and deduplication.
    ///   - title: Short user-facing title.
    ///   - reason: Explanation of why this suggestion was generated.
    ///   - priority: Priority level (defaults to `.normal`).
    ///   - actionPayload: Optional key-value payload for action handlers.
    public init(
        id: UUID = UUID(),
        type: String,
        title: String,
        reason: String,
        priority: EngineSuggestionPriority = .normal,
        actionPayload: [String: String]? = nil
    ) {
        self.id = id
        self.type = type
        self.title = title
        self.reason = reason
        self.priority = priority
        self.timestamp = Date()
        self.actionPayload = actionPayload
    }
}

/// Priority level for proactive engine suggestions.
public enum EngineSuggestionPriority: String, Sendable {
    /// Low priority — informational, non-urgent.
    case low
    /// Normal priority — standard suggestion.
    case normal
    /// High priority — time-sensitive or important.
    case high
}

// MARK: - Intent Prediction

/// The result of a user intent prediction, including confidence and reasoning.
public struct UserIntentPrediction: Sendable {
    /// The predicted intent as a human-readable string (e.g. "morning briefing", "run tests").
    public let predictedIntent: String
    /// Confidence score between 0.0 and 1.0.
    public let confidence: Double
    /// Human-readable explanation of the prediction sources.
    public let reasoning: String
    /// Recommended preparation actions for the predicted intent.
    public let suggestedPreparation: [PreparationAction]
}

/// An action the engine can take to prepare for a predicted intent.
public enum PreparationAction: Sendable {
    /// Pre-warm a specific AI model by name.
    case preWarmModel(String)
    /// Gather context related to the given topic.
    case gatherContext(String)
    /// Preload data for the given key or topic.
    case preloadData(String)
    /// Notify the user with the given message.
    case notifyUser(String)
}

/// An intermediate candidate used during intent aggregation.
struct IntentCandidate {
    /// The predicted intent string.
    let intent: String
    /// Raw confidence score (before aggregation).
    let confidence: Double
    /// The signal source that produced this candidate.
    let source: IntentSource
}

/// The signal source for an ``IntentCandidate``.
enum IntentSource: CustomStringConvertible {
    /// Derived from time-of-day / day-of-week patterns.
    case timePattern
    /// Derived from the sequence of recent queries.
    case querySequence
    /// Derived from current environmental context (battery, location, etc.).
    case contextMatch
    /// Derived from the user's historical behavior.
    case userHistory

    var description: String {
        switch self {
        case .timePattern: return "time patterns"
        case .querySequence: return "recent activity"
        case .contextMatch: return "current context"
        case .userHistory: return "your history"
        }
    }
}

// MARK: - Autonomous Actions

/// An autonomous action that the ``ProactivityEngine`` can execute on behalf of the user.
public struct ProactiveAutonomousAction: Sendable {
    /// Category identifier for the action.
    public let type: String
    /// Human-readable description of what the action does.
    public let description: String
    /// Key-value payload passed to the suggestion system if confirmation is required.
    public let payload: [String: String]
    /// The async closure that performs the action.
    public let execute: @Sendable () async throws -> Void

    /// Create a new autonomous action.
    ///
    /// - Parameters:
    ///   - type: Category identifier.
    ///   - description: Human-readable description.
    ///   - payload: Optional key-value payload (defaults to empty).
    ///   - execute: The async throwing closure that performs the action.
    public init(
        type: String,
        description: String,
        payload: [String: String] = [:],
        execute: @escaping @Sendable () async throws -> Void
    ) {
        self.type = type
        self.description = description
        self.payload = payload
        self.execute = execute
    }
}

/// The result of executing an autonomous action.
public struct ProactiveActionResult: Sendable {
    /// Whether the action completed successfully.
    public let success: Bool
    /// Descriptive message about the outcome.
    public let message: String
}

// MARK: - Context Watch Types

/// A registered watch for monitoring context changes that may invalidate a previous answer.
public struct ContextWatch: Identifiable, Sendable {
    /// Unique identifier for this watch.
    public let id: UUID
    /// The original query being monitored.
    public let query: String
    /// The answer that was provided and is being watched for staleness.
    public let originalAnswer: String
    /// The conversation where this topic was discussed.
    public let conversationId: UUID
    /// Keywords used to search for related new information.
    public let keywords: [String]
    /// When this watch was registered.
    public let registeredAt: Date
    /// When this watch was last checked for new information.
    public var lastChecked: Date?

    /// Create a new context watch.
    ///
    /// - Parameters:
    ///   - id: Unique identifier (defaults to a new UUID).
    ///   - query: The original query to monitor.
    ///   - originalAnswer: The answer to watch for contradictions against.
    ///   - conversationId: The conversation context.
    ///   - keywords: Keywords to monitor.
    ///   - registeredAt: Registration timestamp (defaults to now).
    ///   - lastChecked: Last check timestamp (defaults to `nil`).
    public init(
        id: UUID = UUID(),
        query: String,
        originalAnswer: String,
        conversationId: UUID,
        keywords: [String],
        registeredAt: Date = Date(),
        lastChecked: Date? = nil
    ) {
        self.id = id
        self.query = query
        self.originalAnswer = originalAnswer
        self.conversationId = conversationId
        self.keywords = keywords
        self.registeredAt = registeredAt
        self.lastChecked = lastChecked
    }
}

/// A detected change in context that may affect a previous answer.
public struct ProactiveContextChange: Identifiable, Sendable {
    /// Unique identifier for this change notification.
    public let id: UUID
    /// The ``ContextWatch`` that triggered this change.
    public let watchId: UUID
    /// The conversation where the original answer was given.
    public let conversationId: UUID
    /// The original user query.
    public let originalQuery: String
    /// The original answer that may be outdated.
    public let originalAnswer: String
    /// The newly discovered information.
    public let newInformation: String
    /// Human-readable description of the detected contradiction.
    public let contradictionDetails: String
    /// When the contradiction was detected.
    public let detectedAt: Date
    /// The source of the new information (e.g. memory source type).
    public let source: String

    /// Create a new context change notification.
    ///
    /// - Parameters:
    ///   - id: Unique identifier (defaults to a new UUID).
    ///   - watchId: The originating context watch ID.
    ///   - conversationId: The conversation context.
    ///   - originalQuery: The original user query.
    ///   - originalAnswer: The previous answer.
    ///   - newInformation: The newly found information.
    ///   - contradictionDetails: Description of the contradiction.
    ///   - detectedAt: Detection timestamp (defaults to now).
    ///   - source: The source of the new fact.
    public init(
        id: UUID = UUID(),
        watchId: UUID,
        conversationId: UUID,
        originalQuery: String,
        originalAnswer: String,
        newInformation: String,
        contradictionDetails: String,
        detectedAt: Date = Date(),
        source: String
    ) {
        self.id = id
        self.watchId = watchId
        self.conversationId = conversationId
        self.originalQuery = originalQuery
        self.originalAnswer = originalAnswer
        self.newInformation = newInformation
        self.contradictionDetails = contradictionDetails
        self.detectedAt = detectedAt
        self.source = source
    }
}

/// Result of searching for new facts related to a context watch.
struct NewFactResult {
    /// The textual content of the new fact.
    let content: String
    /// The source system that provided this fact.
    let source: String
    /// When the fact was recorded.
    // periphery:ignore - Reserved: timestamp property reserved for future feature activation
    let timestamp: Date
}
