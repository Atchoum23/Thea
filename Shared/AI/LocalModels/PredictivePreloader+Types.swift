//
//  PredictivePreloader+Types.swift
//  Thea
//
//  Supporting types for PredictivePreloader — data models, enums,
//  and configuration structures used across all prediction subsystems.
//
//  Split from PredictivePreloader.swift for single-responsibility clarity.
//

import Foundation

// MARK: - Core Prediction Types

/// Task with timestamp for history tracking.
///
/// Used by `PredictivePreloader` to maintain an ordered history of user task requests,
/// enabling Markov chain and time-of-day pattern analysis.
struct TaskTypeTimestamp: Codable, Sendable {
    /// The type of task that was requested.
    let taskType: TaskType
    /// When the task was requested.
    let timestamp: Date
}

/// A single task prediction result produced by `PredictivePreloader`.
///
/// Represents a predicted future task type with its probability score and the
/// algorithm source that contributed most to the prediction.
struct TaskPrediction: Sendable {
    /// The predicted task type.
    let taskType: TaskType
    /// Probability score in the range `0.0...1.0`.
    let probability: Double
    /// Which prediction algorithm contributed most to this result.
    let source: PredictionSource
}

/// Identifies which prediction algorithm was the primary contributor.
enum PredictionSource: String, Sendable {
    /// Prediction driven primarily by task-to-task transition probabilities.
    case markovChain = "Markov Chain"
    /// Prediction driven primarily by time-of-day usage patterns.
    case timeOfDay = "Time of Day"
    /// Prediction from a blend of Markov chain and time-of-day signals.
    case combined = "Combined"
}

/// A detected recurring sequence of task types.
///
/// Discovered by sliding-window analysis over the task history. Sequences that
/// occur at least 3 times are considered significant patterns.
struct TaskSequence: Sendable {
    /// The ordered list of task types in this sequence.
    let tasks: [TaskType]
    /// How many times this exact sequence was observed.
    let occurrences: Int
    /// The probability of this sequence relative to the total history length.
    let probability: Double

    /// Human-readable description of the sequence (e.g. "code → debug → test").
    var description: String {
        tasks.map { $0.rawValue }.joined(separator: " → ")
    }
}

/// Aggregate statistics about the prediction engine's learned state.
struct PredictionStats: Sendable {
    /// Total number of task requests recorded in the history.
    let totalTasksRecorded: Int
    /// Number of distinct task types observed.
    let uniqueTaskTypes: Int
    /// Number of unique from-to transition pairs in the Markov matrix.
    let uniqueTransitions: Int
    /// Number of distinct hours that have recorded data.
    let hoursWithData: Int
    /// Shannon entropy of the task distribution (bits). Lower = more predictable.
    let entropy: Double
    /// The task type with the highest frequency, if any.
    let mostFrequentTask: TaskType?

    /// Human-readable description of user behavior predictability.
    ///
    /// Lower entropy indicates more concentrated (predictable) usage patterns.
    var predictability: String {
        switch entropy {
        case 0..<1.5: return "Highly Predictable"
        case 1.5..<2.5: return "Moderately Predictable"
        case 2.5..<3.5: return "Somewhat Predictable"
        default: return "Low Predictability"
        }
    }
}

// MARK: - Time-Based UI Configuration Types

/// A snapshot of UI configuration recommendations based on learned time-of-day patterns.
///
/// Generated by `PredictivePreloader.getTimeBasedUIConfiguration()` and consumed
/// by the UI layer to proactively adapt the interface to expected user activities.
struct TimeBasedUIConfiguration: Sendable {
    /// When this configuration was generated.
    let timestamp: Date
    /// The hour (0-23) used for pattern lookup.
    let hour: Int
    /// The day of week (1=Sunday, 7=Saturday).
    let dayOfWeek: Int
    /// The recommended primary UI mode.
    let primaryMode: UIMode
    /// Distribution of task types expected at this hour.
    let taskDistribution: [TaskType: Double]
    /// Specific UI adjustments recommended.
    let uiRecommendations: [UIRecommendation]
    /// Suggested quick-action buttons for predicted tasks.
    let quickActions: [PredictedQuickAction]
    /// Recommended color theme based on time of day.
    let themePreference: ThemePreference
    /// Confidence score in the range `0.0...1.0` for this configuration.
    let confidence: Double

    /// Whether this configuration has high confidence (>= 0.6).
    var isHighConfidence: Bool {
        confidence >= 0.6
    }

    /// The task type with the highest predicted probability, if any.
    var topPredictedTask: TaskType? {
        taskDistribution.max { $0.value < $1.value }?.key
    }
}

/// UI modes representing different interaction contexts.
///
/// Each mode maps to a set of UI recommendations that optimize the interface
/// for the expected type of work.
enum UIMode: String, Sendable {
    case morning = "Morning"
    case productivity = "Productivity"
    case coding = "Coding"
    case creative = "Creative"
    case research = "Research"
    case conversation = "Conversation"
    case casual = "Casual"
    case evening = "Evening"
    case night = "Night"

    /// A short human-readable description of the mode.
    var description: String {
        switch self {
        case .morning: "Ready to start your day"
        case .productivity: "Focused work mode"
        case .coding: "Development environment"
        case .creative: "Creative writing mode"
        case .research: "Research and analysis"
        case .conversation: "Casual conversation"
        case .casual: "Relaxed interaction"
        case .evening: "Winding down"
        case .night: "Night mode"
        }
    }

    /// SF Symbol name representing this mode.
    var icon: String {
        switch self {
        case .morning: "sunrise"
        case .productivity: "chart.bar"
        case .coding: "chevron.left.forwardslash.chevron.right"
        case .creative: "paintbrush"
        case .research: "magnifyingglass"
        case .conversation: "bubble.left.and.bubble.right"
        case .casual: "face.smiling"
        case .evening: "sunset"
        case .night: "moon.stars"
        }
    }
}

/// Specific UI adjustments that can be applied based on predictions.
enum UIRecommendation: String, Sendable {
    // Code-related
    case showCodeTools = "show_code_tools"
    case enableSyntaxHighlighting = "enable_syntax_highlighting"
    case hideCodeTools = "hide_code_tools"

    // Creative-related
    case showCreativeTools = "show_creative_tools"
    case enableMarkdownPreview = "enable_markdown_preview"

    // Research-related
    case showSourcePanel = "show_source_panel"
    case enableCitations = "enable_citations"

    // Layout
    case expandInputField = "expand_input_field"
    case expandOutputArea = "expand_output_area"
    case showSimplifiedUI = "show_simplified_ui"

    // Productivity
    case showPredictedQuickActions = "show_quick_actions"
    case enableTaskTracking = "enable_task_tracking"
    case showDailyBrief = "show_daily_brief"
    case enableCalendarIntegration = "enable_calendar_integration"
    case showSummaryView = "show_summary_view"

    // Visual
    case enableDarkMode = "enable_dark_mode"
    case reduceBrightness = "reduce_brightness"
    case minimizeAnimations = "minimize_animations"
    case relaxedMode = "relaxed_mode"

    /// Human-readable display name for this recommendation.
    var displayName: String {
        switch self {
        case .showCodeTools: "Show Code Tools"
        case .enableSyntaxHighlighting: "Enable Syntax Highlighting"
        case .hideCodeTools: "Hide Code Tools"
        case .showCreativeTools: "Show Creative Tools"
        case .enableMarkdownPreview: "Enable Markdown Preview"
        case .showSourcePanel: "Show Source Panel"
        case .enableCitations: "Enable Citations"
        case .expandInputField: "Expand Input Field"
        case .expandOutputArea: "Expand Output Area"
        case .showSimplifiedUI: "Show Simplified UI"
        case .showPredictedQuickActions: "Show Quick Actions"
        case .enableTaskTracking: "Enable Task Tracking"
        case .showDailyBrief: "Show Daily Brief"
        case .enableCalendarIntegration: "Enable Calendar Integration"
        case .showSummaryView: "Show Summary View"
        case .enableDarkMode: "Enable Dark Mode"
        case .reduceBrightness: "Reduce Brightness"
        case .minimizeAnimations: "Minimize Animations"
        case .relaxedMode: "Relaxed Mode"
        }
    }
}

/// A quick-action button suggestion for the UI, driven by task predictions.
struct PredictedQuickAction: Sendable, Identifiable {
    /// Unique identifier for this action.
    let id: String
    /// Display title shown on the button.
    let title: String
    /// SF Symbol name for the button icon.
    let icon: String
    /// Action identifier dispatched when the button is tapped.
    let action: String
}

/// Color theme preferences adapted to time of day.
enum ThemePreference: String, Sendable {
    case system = "system"
    case light = "light"
    case dark = "dark"
    case warmLight = "warm_light"
    case warmDark = "warm_dark"

    /// Color temperature adjustment factor (0.0 = neutral, higher = warmer).
    var colorTemperature: Double {
        switch self {
        case .system: 0.0
        case .light: 0.0
        case .dark: 0.0
        case .warmLight: 0.3
        case .warmDark: 0.4
        }
    }
}

/// Analysis of user productivity within a named time block (e.g. "Morning", "Evening").
struct TimeBlockAnalysis: Sendable {
    /// Human-readable name of the time block.
    let name: String
    /// The hour range this block covers.
    let hourRange: ClosedRange<Int>
    /// The most frequent task type in this block, if any.
    let dominantTaskType: TaskType?
    /// Distribution of task types within this block.
    let taskDistribution: [TaskType: Double]
    /// Total number of task samples recorded in this block.
    let totalSamples: Int
    /// Weighted productivity score in the range `0.0...1.0`.
    let productivityScore: Double

    /// Whether enough data has been collected for meaningful analysis (>= 10 samples).
    var hasEnoughData: Bool {
        totalSamples >= 10
    }

    /// Human-readable productivity level label.
    var productivityLevel: String {
        switch productivityScore {
        case 0.8...: "High"
        case 0.6..<0.8: "Medium-High"
        case 0.4..<0.6: "Medium"
        case 0.2..<0.4: "Low-Medium"
        default: "Low"
        }
    }
}
